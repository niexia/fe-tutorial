<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Tire 树 | fe-tutorial</title>
    <meta name="description" content="前端学习笔记">
    <link rel="icon" href="/fe-tutorial/favicon.ico">
    
    <link rel="preload" href="/fe-tutorial/assets/css/0.styles.91d804f8.css" as="style"><link rel="preload" href="/fe-tutorial/assets/js/app.7f4570ce.js" as="script"><link rel="preload" href="/fe-tutorial/assets/js/2.de39cd89.js" as="script"><link rel="preload" href="/fe-tutorial/assets/js/6.bce71aad.js" as="script"><link rel="prefetch" href="/fe-tutorial/assets/js/10.8d64e228.js"><link rel="prefetch" href="/fe-tutorial/assets/js/11.d0f32c2e.js"><link rel="prefetch" href="/fe-tutorial/assets/js/12.c204b372.js"><link rel="prefetch" href="/fe-tutorial/assets/js/13.ea74a8f1.js"><link rel="prefetch" href="/fe-tutorial/assets/js/14.7107ec42.js"><link rel="prefetch" href="/fe-tutorial/assets/js/15.5045221c.js"><link rel="prefetch" href="/fe-tutorial/assets/js/16.8cb30072.js"><link rel="prefetch" href="/fe-tutorial/assets/js/17.1a4335b8.js"><link rel="prefetch" href="/fe-tutorial/assets/js/18.ba0a47ed.js"><link rel="prefetch" href="/fe-tutorial/assets/js/19.3638f3c4.js"><link rel="prefetch" href="/fe-tutorial/assets/js/20.782cfae6.js"><link rel="prefetch" href="/fe-tutorial/assets/js/21.13aa499f.js"><link rel="prefetch" href="/fe-tutorial/assets/js/22.545244e6.js"><link rel="prefetch" href="/fe-tutorial/assets/js/23.81285fb1.js"><link rel="prefetch" href="/fe-tutorial/assets/js/24.ec142ce8.js"><link rel="prefetch" href="/fe-tutorial/assets/js/25.078e00a1.js"><link rel="prefetch" href="/fe-tutorial/assets/js/26.4189b855.js"><link rel="prefetch" href="/fe-tutorial/assets/js/27.c8400168.js"><link rel="prefetch" href="/fe-tutorial/assets/js/28.2b3836e1.js"><link rel="prefetch" href="/fe-tutorial/assets/js/29.78b5bdc8.js"><link rel="prefetch" href="/fe-tutorial/assets/js/3.15ab7a7b.js"><link rel="prefetch" href="/fe-tutorial/assets/js/30.265d9660.js"><link rel="prefetch" href="/fe-tutorial/assets/js/31.dfc25170.js"><link rel="prefetch" href="/fe-tutorial/assets/js/32.17e2c722.js"><link rel="prefetch" href="/fe-tutorial/assets/js/33.95d757cc.js"><link rel="prefetch" href="/fe-tutorial/assets/js/34.1dff971d.js"><link rel="prefetch" href="/fe-tutorial/assets/js/35.ff8dfe22.js"><link rel="prefetch" href="/fe-tutorial/assets/js/36.ec3e1a55.js"><link rel="prefetch" href="/fe-tutorial/assets/js/37.2a62fcc6.js"><link rel="prefetch" href="/fe-tutorial/assets/js/38.8cabc605.js"><link rel="prefetch" href="/fe-tutorial/assets/js/39.e9b03dba.js"><link rel="prefetch" href="/fe-tutorial/assets/js/4.b59c0b71.js"><link rel="prefetch" href="/fe-tutorial/assets/js/40.6af305bb.js"><link rel="prefetch" href="/fe-tutorial/assets/js/41.328f7d5f.js"><link rel="prefetch" href="/fe-tutorial/assets/js/42.e89af924.js"><link rel="prefetch" href="/fe-tutorial/assets/js/43.ed04ea33.js"><link rel="prefetch" href="/fe-tutorial/assets/js/44.d3bb748d.js"><link rel="prefetch" href="/fe-tutorial/assets/js/45.bd04230f.js"><link rel="prefetch" href="/fe-tutorial/assets/js/46.96faa448.js"><link rel="prefetch" href="/fe-tutorial/assets/js/47.a9f2e4a9.js"><link rel="prefetch" href="/fe-tutorial/assets/js/48.5dd22e6b.js"><link rel="prefetch" href="/fe-tutorial/assets/js/49.10d7f582.js"><link rel="prefetch" href="/fe-tutorial/assets/js/5.dff8f486.js"><link rel="prefetch" href="/fe-tutorial/assets/js/50.4dcd6998.js"><link rel="prefetch" href="/fe-tutorial/assets/js/51.9f7cc436.js"><link rel="prefetch" href="/fe-tutorial/assets/js/52.17130e3b.js"><link rel="prefetch" href="/fe-tutorial/assets/js/53.d8d6e013.js"><link rel="prefetch" href="/fe-tutorial/assets/js/54.b99696bb.js"><link rel="prefetch" href="/fe-tutorial/assets/js/55.c62fca06.js"><link rel="prefetch" href="/fe-tutorial/assets/js/56.fd70dca8.js"><link rel="prefetch" href="/fe-tutorial/assets/js/57.f94438ee.js"><link rel="prefetch" href="/fe-tutorial/assets/js/58.16bfab68.js"><link rel="prefetch" href="/fe-tutorial/assets/js/59.32cdfa79.js"><link rel="prefetch" href="/fe-tutorial/assets/js/60.353e888f.js"><link rel="prefetch" href="/fe-tutorial/assets/js/61.b4b57cfa.js"><link rel="prefetch" href="/fe-tutorial/assets/js/62.828d0ace.js"><link rel="prefetch" href="/fe-tutorial/assets/js/63.22be5933.js"><link rel="prefetch" href="/fe-tutorial/assets/js/64.68c6130f.js"><link rel="prefetch" href="/fe-tutorial/assets/js/65.2d04ec09.js"><link rel="prefetch" href="/fe-tutorial/assets/js/66.ad2981b5.js"><link rel="prefetch" href="/fe-tutorial/assets/js/67.82ae41ab.js"><link rel="prefetch" href="/fe-tutorial/assets/js/68.46ac36ff.js"><link rel="prefetch" href="/fe-tutorial/assets/js/69.26136903.js"><link rel="prefetch" href="/fe-tutorial/assets/js/7.7bd46426.js"><link rel="prefetch" href="/fe-tutorial/assets/js/70.e34d5b6e.js"><link rel="prefetch" href="/fe-tutorial/assets/js/71.657398c4.js"><link rel="prefetch" href="/fe-tutorial/assets/js/72.a4f5e86c.js"><link rel="prefetch" href="/fe-tutorial/assets/js/73.dc5e22d7.js"><link rel="prefetch" href="/fe-tutorial/assets/js/74.da476ef9.js"><link rel="prefetch" href="/fe-tutorial/assets/js/75.a149f6be.js"><link rel="prefetch" href="/fe-tutorial/assets/js/76.5a8c3430.js"><link rel="prefetch" href="/fe-tutorial/assets/js/77.2bb95403.js"><link rel="prefetch" href="/fe-tutorial/assets/js/78.17672a6f.js"><link rel="prefetch" href="/fe-tutorial/assets/js/79.b75a37f5.js"><link rel="prefetch" href="/fe-tutorial/assets/js/8.f41d23fd.js"><link rel="prefetch" href="/fe-tutorial/assets/js/80.9d6ed8c5.js"><link rel="prefetch" href="/fe-tutorial/assets/js/81.76b9c16a.js"><link rel="prefetch" href="/fe-tutorial/assets/js/82.b5eaa9f4.js"><link rel="prefetch" href="/fe-tutorial/assets/js/83.2f3bb3f6.js"><link rel="prefetch" href="/fe-tutorial/assets/js/84.137b593e.js"><link rel="prefetch" href="/fe-tutorial/assets/js/85.bf0db3d3.js"><link rel="prefetch" href="/fe-tutorial/assets/js/86.3445ead8.js"><link rel="prefetch" href="/fe-tutorial/assets/js/9.830356f0.js">
    <link rel="stylesheet" href="/fe-tutorial/assets/css/0.styles.91d804f8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/fe-tutorial/" class="home-link router-link-active"><!----> <span class="site-name">fe-tutorial</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fe-tutorial/algo/" class="nav-link router-link-active">数据结构和算法</a></div><div class="nav-item"><a href="/fe-tutorial/javaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/fe-tutorial/webpack/" class="nav-link">Webpack</a></div><div class="nav-item"><a href="https://niexias.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/niexias" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/fe-tutorial/algo/" class="nav-link router-link-active">数据结构和算法</a></div><div class="nav-item"><a href="/fe-tutorial/javaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/fe-tutorial/webpack/" class="nav-link">Webpack</a></div><div class="nav-item"><a href="https://niexias.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/niexias" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数据结构和算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/" class="sidebar-link">介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数组</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/数组/数组.html" class="sidebar-link">数组</a></li><li><a href="/fe-tutorial/algo/数组/练习.html" class="sidebar-link">练习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>链表</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/链表/链表.html" class="sidebar-link">链表</a></li><li><a href="/fe-tutorial/algo/链表/手写链表的技巧.html" class="sidebar-link">手写链表的技巧</a></li><li><a href="/fe-tutorial/algo/链表/练习.html" class="sidebar-link">练习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>栈</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/栈/栈.html" class="sidebar-link">栈</a></li><li><a href="/fe-tutorial/algo/栈/练习.html" class="sidebar-link">练习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>队列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/队列/队列.html" class="sidebar-link">队列</a></li><li><a href="/fe-tutorial/algo/队列/练习.html" class="sidebar-link">练习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>递归</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/递归/递归.html" class="sidebar-link">理解递归</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>排序</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/排序/排序.html" class="sidebar-link">排序算法介绍</a></li><li><a href="/fe-tutorial/algo/排序/冒泡、插入和选择排序.html" class="sidebar-link">冒泡、插入和选择排序</a></li><li><a href="/fe-tutorial/algo/排序/归并排序和快速排序.html" class="sidebar-link">归并排序和快速排序</a></li><li><a href="/fe-tutorial/algo/排序/桶排序、计数排序和基数排序.html" class="sidebar-link">桶排序、计数排序和基数排序</a></li><li><a href="/fe-tutorial/algo/排序/排序优化.html" class="sidebar-link">排序优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>二分查找</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/二分查找/二分查找.html" class="sidebar-link">二分查找</a></li><li><a href="/fe-tutorial/algo/二分查找/二分查找的变形.html" class="sidebar-link">二分查找的变形</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>跳表</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/跳表/跳表.html" class="sidebar-link">跳表</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>散列表</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/散列表/散列表.html" class="sidebar-link">散列表</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>哈希算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/哈希算法/哈希算法.html" class="sidebar-link">哈希算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>二叉树</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/二叉树/二叉树.html" class="sidebar-link">二叉树</a></li><li><a href="/fe-tutorial/algo/二叉树/二叉查找树.html" class="sidebar-link">二叉查找树</a></li><li><a href="/fe-tutorial/algo/二叉树/红黑树.html" class="sidebar-link">红黑树</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>堆</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/堆/堆和堆排序.html" class="sidebar-link">堆</a></li><li><a href="/fe-tutorial/algo/堆/堆的应用.html" class="sidebar-link">堆的应用</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>图</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/图/图.html" class="sidebar-link">图</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>字符串匹配</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/字符串匹配/BF算法和RK算法.html" class="sidebar-link">BF 算法和 RK 算法</a></li><li><a href="/fe-tutorial/algo/字符串匹配/BM算法.html" class="sidebar-link">/algo/字符串匹配/BM算法.html</a></li><li><a href="/fe-tutorial/algo/字符串匹配/KMP算法.html" class="sidebar-link">/algo/字符串匹配/KMP算法.html</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Tire树</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/Tire树/Tire树.html" class="active sidebar-link">Tire 树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe-tutorial/algo/Tire树/Tire树.html#什么是-tire-树" class="sidebar-link">什么是 Tire 树</a></li><li class="sidebar-sub-header"><a href="/fe-tutorial/algo/Tire树/Tire树.html#实现-tire-树" class="sidebar-link">实现 Tire 树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe-tutorial/algo/Tire树/Tire树.html#tire-树主要有两个操作" class="sidebar-link">Tire 树主要有两个操作</a></li><li class="sidebar-sub-header"><a href="/fe-tutorial/algo/Tire树/Tire树.html#经典的存储方式" class="sidebar-link">经典的存储方式</a></li><li class="sidebar-sub-header"><a href="/fe-tutorial/algo/Tire树/Tire树.html#实现构造和查询" class="sidebar-link">实现构造和查询</a></li><li class="sidebar-sub-header"><a href="/fe-tutorial/algo/Tire树/Tire树.html#tire-树是否真的耗内存" class="sidebar-link">Tire 树是否真的耗内存</a></li></ul></li><li class="sidebar-sub-header"><a href="/fe-tutorial/algo/Tire树/Tire树.html#tire-树与散列表、红黑树的比较" class="sidebar-link">Tire 树与散列表、红黑树的比较</a></li><li class="sidebar-sub-header"><a href="/fe-tutorial/algo/Tire树/Tire树.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>贪心算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/贪心算法/贪心算法.html" class="sidebar-link">贪心算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>分治算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/分治算法/分治算法.html" class="sidebar-link">分治算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>回溯算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/回溯算法/回溯算法.html" class="sidebar-link">回溯算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>动态规划</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algo/动态规划/动态规划.html" class="sidebar-link">动态规划</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="tire-树"><a href="#tire-树" aria-hidden="true" class="header-anchor">#</a> Tire 树</h1> <p>为了方便输入，当你在搜索引擎的搜索框中，输入要搜索的文字的某一部分，搜索引擎就会自动弹出下拉框，里面是各种关键词提示。然后可以直接选择，而不必输入所有内容。</p> <p><img src="/fe-tutorial/assets/img/dataStructure-tire-eg1.6d1322ea.png" alt="search completion"></p> <p>它是怎么实现的呢？底层使用的是那种数据结构和算法呢？</p> <p>这些搜索引擎的关键词提示功能肯定做了很多优化，但是底层最基本的就是 Tire 树这种数据结构。</p> <h2 id="什么是-tire-树"><a href="#什么是-tire-树" aria-hidden="true" class="header-anchor">#</a> 什么是 Tire 树</h2> <p>Tire 树，也叫字典树。顾名思义，它是一种树形结构。这种数据结构专门处理字符串匹配，用来解决在一组字符串集合中快速查找某个字符串的问题。</p> <p><strong>Tire 树的本质，就是利用字符串之间的公共前缀，将重复的前缀组合在一起</strong>。</p> <p>举个例子，现在有 6 个字符串：how，hi，her，hello，so，see。我们希望在里面多次查找某个字符串是否存在。如果每次查找都是将要查找的字符串和这 6 个字符串匹配，那么效率就比较低了。有没有更高效的方法？</p> <p>这时候，可以先对这 6 个字符串做一下预处理，组织成 Tire 树的结构。之后每次查找，都是在 Tire 中进行匹配查找：</p> <p><img src="/fe-tutorial/assets/img/dataStructure-tire-eg2.df796e56.png" alt="tire"></p> <p>Tire 的构造过程如下，每一步都相当于往 Tire 树中插入一个字符串，所有字符串都插入完成之后，Tire 树就构造好了。</p> <p><img src="/fe-tutorial/assets/img/dataStructure-tire-eg3.5c72db1b.png" alt="tire"></p> <p>在 Tire 树中查找一个字符串的时候，比如查找“her”，先将它分割成单个字符串 h，e，r，然后从 Tire 树的根节点开始匹配。如果所示，绿色的路径就是在 Tire 树中的匹配路径。</p> <p><img src="/fe-tutorial/assets/img/dataStructure-tire-eg4.eb6ec344.png" alt="tire"></p> <p>如果要查找 “he”，方法还是一样的，如图所示，绿色路径就是“he”的匹配路径。但是有点不同，<strong>路径的最后一个节点“e”并不是红色的</strong>，也就是说，“he”是某个字符串的前缀，它并不能完全匹配任何字符串。</p> <p><img src="/fe-tutorial/assets/img/dataStructure-tire-eg5.12baf126.png" alt="tire"></p> <h2 id="实现-tire-树"><a href="#实现-tire-树" aria-hidden="true" class="header-anchor">#</a> 实现 Tire 树</h2> <h3 id="tire-树主要有两个操作"><a href="#tire-树主要有两个操作" aria-hidden="true" class="header-anchor">#</a> Tire 树主要有两个操作</h3> <ul><li>构造：将字符串集合构造成 Tire 树。这个过程拆开来看，就是将字符串插入 Tire 树的过程。</li> <li>查询：在 Tire 树中查询一个字符串。</li></ul> <p>从前面的图可以看出，Tire 树是一棵多叉树。在二叉树中，一个节点的左右子节点是通过两个指针来存储的，那在多叉树中，怎么存储一个节点的所有子节点的指针呢？</p> <h3 id="经典的存储方式"><a href="#经典的存储方式" aria-hidden="true" class="header-anchor">#</a> 经典的存储方式</h3> <p>借助散列表的思想，<strong>通过一个下标与字符一一映射的数组，来存储子节点的指针</strong>。如下图：</p> <p><img src="/fe-tutorial/assets/img/dataStructure-tire-eg6.467a95ed.png" alt="tire"></p> <p>假设我们的字符串只有 a~z 这 26 个小写字母。那么，在数组下标为 0 的位置存储指向子节点 a 的指针，下标为 1 的位置存储指向子节点 b 的指针，以此类推，下标为 25 的位置存储指向子节点 z 的指针。如果某个节点不存在，那么就在对应的下标位置存储 null。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每个下标位置存储的是指向对应子节点的指针</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="实现构造和查询"><a href="#实现构造和查询" aria-hidden="true" class="header-anchor">#</a> 实现构造和查询</h3> <p>接下来，实现构造和查询。当我们在 Tire 树行查找字符串的时候，就可以通过字符的 ASCII 码减去“a”的 ASCII 码（得到的就是数组下标），迅速的找到匹配的子节点的指针。比如 d - a = 3，那子节点 d 的指针就存储在数组下标为 3 的位置。</p> <p>整个过程代码的实现为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isEndingChar <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">TrieTree</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 往 Trie 树中插入一个字符串</span>
  <span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> char <span class="token keyword">of</span> text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> index <span class="token operator">=</span> char<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    node<span class="token punctuation">.</span>isEndingChar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 在 Trie 树中查找一个字符串</span>
  <span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> char <span class="token keyword">of</span> text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> index <span class="token operator">=</span> char<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> node<span class="token punctuation">.</span>isEndingChar<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> strs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;how&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hi&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;her&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;so&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;see&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> str <span class="token keyword">of</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  tree<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> str <span class="token keyword">of</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>那么在 Tire 树中，查找某个字符串的时间复杂是多少？</strong></p> <p>如果要在一组字符串中，频繁地查询某些字符串，用 Trie 树会非常高效。</p> <p>构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 <strong>O(n)（n 表示所有字符串的长度和</strong>）。但是一旦构建成功之后，后续的查询操作会非常高效。</p> <p>每次查询时，如果要查询的字符串长度是 k，那我们只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的时间复杂度是 <strong>O(k)</strong>，k 表示要查找的字符串的长度。</p> <h3 id="tire-树是否真的耗内存"><a href="#tire-树是否真的耗内存" aria-hidden="true" class="header-anchor">#</a> Tire 树是否真的耗内存</h3> <p>存储 Tire 树时，用数组来存储一个节点的子节点的指针。</p> <p>如果字符串中包含 a~z 这 26 个字符，那么每个节点都需要存储一个长度为 26 的数组，并且每个数组元素存储一个 8 字节指针（或者 4 个字节，跟 CPU、操作系统、编译器等有关）。而且，不管一个节点有多少个子节点，我们都需要维护这个长度为 26 的数组。</p> <p>按照上面的例子，数组长度是 26，每个元素是 8 个字节，所以每个节点额外需要 26 * 8 = 208 个字节。而且这还是只包含 26 个字符的情况。</p> <p>如果字符串中，不仅包含小写字母，还包含大写字母、数字、甚至中文，那么需要的存储空间就更多了。</p> <p>Tire 树的本质是将重复的前缀组合在一起，避免重复存储。但是，在某些情况下，Tire 树并不能节省存储空间。在重复前缀并不多的情况下，Tire 不但不能节省空间，还有可能浪费更多的内存。</p> <p><strong>所以 Tire 树是比较耗内存的，是一种空间换时间的解决思路。</strong></p> <p>可以牺牲一点查询效率，将每个节点中的数组换成其他数据结构，来存储一个子节点的指针。比如有序数组、跳表、散列表、红黑树等。</p> <p>假设是有序数组，查询的时候，可以通过二分查找的方法，快速找到某个字符应该匹配的子节点的指针。往 Tire 插入一个字符串时，需要维护数组中数据的有序性，就会稍微慢点。</p> <p>Tire 的变体都可以在一定程度上解决内存的销毁问题。比如，还有<strong>缩点优化</strong>，就是对于只有一个子节点的节点，可以将此节点与子节点合并。也可以节省空间。</p> <p><img src="/fe-tutorial/assets/img/dataStructure-tire-eg7.e8bd235d.png" alt="tire"></p> <h2 id="tire-树与散列表、红黑树的比较"><a href="#tire-树与散列表、红黑树的比较" aria-hidden="true" class="header-anchor">#</a> Tire 树与散列表、红黑树的比较</h2> <p>支持数据动态操作的数据有，散列表、红黑树、跳表等。这些数据结构也可以实现在一组字符串中查找字符串的功能。这里做个比较。</p> <p>在刚刚这个场景中，Tire 树实际上表现得并不好，它对处理的字符串有极其严苛的要求：</p> <ol><li>字符串包含的字符集不能太大。字符集太大，存储空间就会浪费很多。</li> <li>字符串的前缀重合要比较多，不然消耗也会变大很多。</li> <li>要用 Tire 树，首先需要从零开始实现一个 Tire 树，这个在工程上是简单问题复杂化了，除非必须，一般不建议这样做。</li> <li>通过指针串起来的数据块不是连续的，而 Tire 树中用到了指针，所以这对缓存并不友好，性能会打折扣。</li></ol> <p>针对在一组字符串中查找字符串的问题，在工程中，更倾向于用散列表或者红黑树。因为这两种数据结构，我们都不需要自己去实现，直接利用编程语言中提供的现成类库就行了。</p> <p><strong>Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适合的是查找前缀匹配的字符串，也就是类似开篇的关键词提示那种场景。</strong></p> <h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2> <p>解答开篇问题，假设关键词词库是由用户的热门搜索关键词组成，先将这个词库构建成 Tire 树，当用户其中某个单词时，把这个词作为前缀子串在 Tire 树中匹配，将满足这个匹配的关键词展示在搜索提示框。这就是搜索关键词的最基本算法原理。</p> <p>Trie 树的这个应用可以扩展到更加广泛的一个应用上，就是<strong>自动输入补全</strong>，比如输入法自动补全功能、IDE 代码编辑器自动补全功能、浏览器网址输入的自动补全功能等等。</p> <p>最后总结一下，Tire 树是一种解决字符串快速匹配的数据结构。它比较耗内存，是一种空间换时间的解决问题思路。当然，在 Tire 树中做字符串匹配非常高效，时间复杂度是 O(k)，k 是要匹配的字符串的长度。</p> <p>Trie 树的优势并不在于，用它来做动态集合数据的查找，因为，这个工作完全可以用更加合适的散列表或者红黑树来替代。<strong>Trie 树最有优势的是查找前缀匹配的字符串</strong>，比如搜索引擎中的关键词提示功能这个场景，就比较适合用它来解决，也是 Trie 树比较经典的应用场景。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">11/28/2019, 1:25:03 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/fe-tutorial/algo/字符串匹配/KMP算法.html" class="prev">/algo/字符串匹配/KMP算法.html</a></span> <span class="next"><a href="/fe-tutorial/algo/贪心算法/贪心算法.html">贪心算法</a>→
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/fe-tutorial/assets/js/app.7f4570ce.js" defer></script><script src="/fe-tutorial/assets/js/2.de39cd89.js" defer></script><script src="/fe-tutorial/assets/js/6.bce71aad.js" defer></script>
  </body>
</html>
