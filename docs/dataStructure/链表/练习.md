# 练习

## 1. 单链表反转

思路：以链表的头结点为基准，遍历链表，每次将该基准的下个节点移到头部作为头结点，直到基准节点是变成尾结点。

```js
function reverseLinkedList(head) {
  let currentNode = null;
  let headNode = head;

  while (head && head.next) {
    currentNode = head.next;
    head.next = currentNode.next;
    currentNode.next = headNode;
    headNode = currentNode;
  }

  return headNode;
}
```

## 2. 链表中环的检测

![cycleDetection](../../.vuepress/public/images/dataStructure-linked-cycleDetection.png)

思路：就是有两个指针 P1 和 P2，同时从头结点开始往下遍历链表中的所有节点。

- P1 是慢指针，一次遍历一个节点。
- P2 是快指针，一次遍历两个节点。

如果链表中没有环，P2 和 P1 会先后遍历完所有的节点。如果链表中有环，P2 和 P1 则会先后进入环中，一直循环，并一定会在在某一次遍历中相遇。

因此，只要发现 P2 和 P1 相遇了，就可以判定链表中存在环。就好像在跑道上跑步一样。

```js
function checkCircle(head) {
  let fast = head.next;
  let slow = head;
  while (fast !== null && fast.next !== null) {
    fast = fast.next.next;
    slow = slow.next;
    if (slow === fast) {
      return true;
    }
  }
  return false;
}
```

## 3. 删除链表倒数第 n 个结点

思路：我们并不知道链表有多长。简单的方法，先遍历一遍，获取到链表的长度 length，再遍历第二步，找到第 length-k 个结点，即为倒数第 k+1 个结点，将它指向下下个结点，就完成删除。

更好的方法，定义两个前后指针，p 和 q，q 先向前走 k 步，然后 p 再开始走，当 q 指针走到链表结尾的时候，p 就正好走到倒数第 k+1 个结点，只需要遍历一次。

可能有点绕，可以这么说，q 开始比 p 多走 k 步，那么结束的时候，p 反过来比 q 少走 k 步，所以 p 此时对应的是倒数第 k+1 个结点。

```js
function removeNthFromEnd(head, k) {
  let front = head;
  let behind = head;

  while(k-- && front) {
    front = front.next;
  }

  if (front == null) {
    return behind.next;
  }

  while (front.next) {
    front = front.next;
    behind = behind.next;
  }
  behind.next = behind.next.next;

  return head;
}
```

## 4. 求链表的中间节点

思路：可以先遍历一遍，获取链表长度。然后再遍历一遍，判断当前节点的位置是否是中点。不过最好办法是和环的检测一样，通过快慢指针，快指针的速度是慢指针的 2 倍，这样快指针到了尾结点，慢指针指向的就是中间结点。

```js
// 遍历
function middleNode(head) {
  let node = head;
  let count = 0;
  let middle = 0;
  while (node) {
    node = node.next;
    ++count;
  }
  node = head;
  while (node) {
    ++middle;
    if (middle / count > 0.5) {
      return node;
    } else {
      node = node.next;
    }
  }
}

// 快慢指针
function middleNode(head) {
  if (head === null) return null;
  let fast = head.next;
  let slow = head;
  while (fast !== null && fast.next !== null) {
    fast = fast.next.next;
    slow = slow.next;
  }
  return slow;
}
```

## 5. 合并两个有序链表

思路：链表头结点比较，取较小的节点。小节点的 next 等于小节点的 next 和 大节点的较小值，依次递归，最后返回头结点

```js
function mergeLists(head1, head2) {
  if (!head1) return head2;
  if (!head2) return head1;

  let head;
  if (head1.val < head2.val) {
    head = head1;
    head.next = mergeLists(head.next, head2);
  } else {
    head = head2;
    head.next = mergeLists(head1, head2.next);
  }

  return head;
}
```

## 整个代码实现

```js
class Node {
  constructor(val) {
    this.element = val;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
  }

  // 根据 value 查找
  findByValue(value) {
    let currentNode = this.head;
    while (currentNode !== null && currentNode.element !== value) {
      currentNode = currentNode.next;
    }
    return currentNode === null ? -1 : currentNode;
  }

  // 根据 index 查找
  findByIndex(index) {
    let currentNode = this.head;
    let pos = 0;
    while (currentNode !== null && pos !== index) {
      currentNode = currentNode.next;
      pos++;
    }
    return currentNode == null ? -1 : currentNode;
  }

  // 链表头部插入，这种操作将和输入的顺序相反，逆序
  insertHead(newValue) {
    let newNode = new Node(newValue);
    newNode.next = this.head;
    this.head = newNode;
  }

  // 链表尾部插入，顺序插入
  insertTail(newValue) {
    let newNode = new Node(newValue);
    let currentNode = this.head;
    // 先判断是否为空链表
    if (currentNode === null) {
      this.head = newNode;
      return;
    }
    while (currentNode.next !== null) {
      currentNode = currentNode.next;
    }
    currentNode.next = newNode;
  }

  // 指定元素之前插入
  insertBefore(newValue, value) {
    if (this.head === null) return false;
    let currentNode = this.head;
    let pervNode = null;
    while (currentNode !== null && currentNode.element !== value) {
      pervNode = currentNode;
      currentNode = currentNode.next;
    }
    // 没有找到 value 对应的结点
    if (currentNode === null) return false;

    let newNode = new Node(newValue);
    // 在头结点之前插入
    if (preNode === null) {
      newNode.next = this.head;
      this.head = newNode;
    } else {
      newNode.next = prevNode.next;
      prevNode.next = newNode;
    }
  }

  // 指定元素之后插入
  insertAfter(newValue, value) {
    let currentNode = this.findByValue(value);
    if (currentNode === -1) {
      console.log('未找到插入位置');
      return;
    }
    let newNode = new Node(newValue);
    newNode.next = currentNode.next;
    currentNode.next = newNode;
  }

  // 查找前一个结点
  // findPrev(value) {
  //   let currentNode = this.head;
  //   if (currentNode === null) return -1;
  //   while (currentNode.next !== null && currentNode.next.element !== value) {
  //     currentNode = currentNode.next;
  //   }
  //   return currentNode.next === null ? -1 : currentNode;
  // }

  // 根据值删除
  remove(value) {
    if (this.head === null) return false;
    let currentNode = this.head;
    let pervNode = null;
    while (currentNode !== null && currentNode.element !== value) {
      pervNode = currentNode;
      currentNode = currentNode.next;
    }
    // 没有找到 value 对应的结点
    if (currentNode === null) return false;
    // value 对应的是头结点
    if (preNode === null) {
      this.head = this.head.next;
    } else {
      pervNode.next = prevNode.next.next;
    }
    return true;
  }

  // 遍历所有节点
  display() {
    let currentNode = this.head;
    while (currentNode !== null) {
      console.log(currentNode.element);
      currentNode = currentNode.next;
    }
  }

  // 1. 反转链表，尾插法
  reverseList() {
    let currentNode = this.head;
    let prevNode = null;
    // 以链表的头结点为基准，遍历链表
    while (currentNode !== null) {
      // 先保存下一个节点，因为下一步会改变 next 的指向
      let nextNode = currentNode.next;
      // 将基准结点的 next 指向上一个结点
      currentNode.next = prevNode;
      // 将基准结点赋给 prevNode
      prevNode = currentNode;
      // 将基准结点的下一个节点作为基准结点
      currentNode = nextNode
    }
    this.head = prevNode;
  }

  // 2. 环的检测
  checkCircle() {
    if (this.head === null) return false;
    let fast = this.head.next;
    let slow = this.head;
    while (fast !== null && fast.next !== null) {
      fast = fast.next.next;
      slow = slow.next;
      if (fast === slow) {
        return true;
      }
    }
    return false;
  }
  
  // 3. 删除倒数第 k 个结点
  removeLastKth(k) {
    let fast = this.head;
    let slow = this.head;
    let i = 1;
    // 先走 k 步
    while (fast !== null && i <= k) {
      fast = fast.next;
      ++1;
    }
    if (fast === null) return false;
    // 遍历，直到 fast 是尾结点
    while (fast.next !== null) {
      fast = fast.next;
      slow = slow.next;
    }
    // slow 就是倒数第 k+1 个结点，删除倒数第 k 个结点
    slow.next = slow.next.next;
    return true;
  }

  // 4. 求中间节点
  findMiddleNode() {
    if (this.head === null) return null;
    let fast = this.head;
    let slow = this.head;
    while (fast !== null && fast.next !== null) {
      fast = fast.next.next;
      slow = slow.next;
    }
    return slow;
  }
}

// 5. 合并两个有序链表
function mergeTowLists(l1, l2) {
  // 利用哨兵结点简化实现难度
  let soldier = new Node(0);
  let p = soldier;
  while (l1 !== null && l2 !== null) {
    if (l1.element < l2.element) {
      p.next = l1;
      l1 = l1.next;
    } else {
      p.next = l2;
      l2 = l2.next;
    }
    p = p.next;
  }
  if (l1 !== null) p.next = l1;
  if (l2 !== null) p.next = l2;
  return soldier.next;
}

// test
const link = new LinkedList();
link.appendTail(1);
link.appendTail(2);
link.appendTail(3);
link.appendTail(4);
link.display(); // 1 -> 2 -> 3 -> 4

console.log('----------------insertAfter----------------');
link.insertAfter(1, 5); // 结点 1 之后插入元素
link.insertAfter(4, 6); // 结点 4 之后插入元素
link.display(); // 1 -> 5 -> 2 -> 3 -> 4 -> 6

console.log('----------------remove----------------');
link.remove(5);
link.remove(1);
link.display(); // 1 -> 2 -> 3 -> 4 -> 6

console.log('-------------find by value------------');
link.findByValue(4); // {element 4, next: {..}}

console.log('-------------find by index------------');
link.findByIndex(3); // {element 4, next: {..}}
```


