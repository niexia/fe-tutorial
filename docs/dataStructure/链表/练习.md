# 练习

## 单链表反转

输入一个链表，反转链表之后，输出新链表的表头

### 思路

以链表的头结点为基准，遍历链表，每次将该基准的下个节点移到头部作为头结点，直到基准节点是变成尾结点。

### 代码实现

```js
function reverseLinkedList(head) {
  let currentNode = null;
  let headNode = head;

  while (head && head.next) {
    currentNode = head.next;
    head.next = currentNode.next;
    currentNode.next = headNode;
    headNode = currentNode;
  }

  return headNode;
}
```

## 链表中环的检测

如何检测一个单链表中是否有环，如下图

![cycleDetection](../../.vuepress/public/images/dataStructure-linked-cycleDetection.png)

### 思路

就是有两个指针 P1 和 P2，同时从头结点开始往下遍历链表中的所有节点。

P1 是慢指针，一次遍历一个节点。
P2 是快指针，一次遍历两个节点。

如果链表中没有环，P2 和 P1 会先后遍历完所有的节点。如果链表中有环，P2 和 P1 则会先后进入环中，一直循环，并一定会在在某一次遍历中相遇。

因此，只要发现 P2 和 P1 相遇了，就可以判定链表中存在环。就好像在跑道上跑步一样。

### 代码实现

```js
function checkCircle(head) {
  let fast = head.next;
  let slow = head;
  while (fast !== null && fast.next !== null) {
    fast = fast.next.next;
    slow = slow.next;
    if (slow === fast) {
      return true;
    }
  }
  return false;
}
```

## 两个有序链表的合并

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

### 思路

链表头结点比较，取较小的节点。小节点的 next 等于小节点的 next 和 大节点的较小值，依次递归，最后返回头结点

### 代码实现

```js
function mergeLists(head1, head2) {
  if (!head1) return head2;
  if (!head2) return head1;

  let head;
  if (head1.val < head2.val) {
    head = head1;
    head.next = mergeLists(head.next, head2);
  } else {
    head = head2;
    head.next = mergeLists(head1, head2.next);
  }

  return head;
}
```

## 删除链表倒数第 n 个结点

输入一个链表，删除该链表中倒数第 k 个结点，返回链表的头结点。

例如，给出链表 `1->2->3->4->5->null` 和 `k=2`，则删除倒数第 2 个结点之后，这个链表就变成 `1->2->3->5->null`。

### 思路

我们并不知道链表有多长。简单的方法，先遍历一遍，获取到链表的长度 length，再遍历第二步，找到第 length-k 个结点，即为倒数第 k+1 个结点，将它指向下下个结点，就完成删除。

更好的方法，定义两个前后指针，p 和 q，q 先向前走 k 步，然后 p 再开始走，当 q 指针走到链表结尾的时候，p 就正好走到倒数第 k+1 个结点，只需要遍历一次。

可能有点绕，可以这么说，q 开始比 p 多走 k 步，那么结束的时候，p 反过来比 q 少走 k 步，所以 p 此时对应的是倒数第 k+1 个结点。

### 代码实现

```js
function removeNthFromEnd(head, k) {
  let front = head;
  let behind = head;

  while(n-- && front) {
    front = front.next;
  }

  if (front == null) {
    return behind.next;
  }

  while (front.next) {
    front = front.next;
    behind = behind.next;
  }
  behind.next = behind.next.next;

  return head;
}
```

## 求链表的中间节点

给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。

例如，输入 `1->2->3->4->5`，返回结点 3；输入 `1->2->3->4->5->6` 返回结点 4。

### 代码实现

```js
function middleNode(head) {
  let node = head;
  let count = 0;
  let middle = 0;
  while (node) {
    node = node.next;
    ++count;
  }
  node = head;
  while (node) {
    ++middle;
    if (middle / count > 0.5) {
      return node;
    } else {
      node = node.next;
    }
  }
}
```

