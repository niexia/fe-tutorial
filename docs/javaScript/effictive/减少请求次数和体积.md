# 减少请求次数和体积

HTTP 连接这一层面的优化才是网络优化的核心，有两大方向：**减少请求次数**和**减少单次请求花费的时间**。

这两个优化直接对应到了日常开发的操作————资源的压缩和合并，这个一般需要配合打包工具一起。在使用 webpack 的时候我们可以做一些优化。

## webpack 要做的优化

### 加快构建速度

1. 不要让 loader 做太多事情

以 [babel-loader](https://webpack.docschina.org/loaders/babel-loader/) 为例，可以配置 `exclude` 排除特定条件，看一下一个官方的例子：

```js
module: {
  rules: [
    {
      test: /\.m?js$/,
      exclude: /(node_modules|bower_components)/,
      use: {
        loader: 'babel-loader',
        options: {
          presets: ['@babel/preset-env']
        }
      }
    }
  ]
}
```

这样就避免对 node_modules 文件夹或者 bower_components 文件夹进行处理。

另外还可以开启缓存 `cacheDirectory`，设置之后，指定的目录（默认是 `node_modules/.cache/babel-loader`）将用来缓存 loader 的执行结果。之后的 webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程(recompilation process)。

```js
module: {
  rules: [
    {
      test: /\.m?js$/,
      exclude: /(node_modules|bower_components)/,
      use: {
        // 或者 loader: 'babel-loader?cacheDirectory=true'
        loader: 'babel-loader?cacheDirectory',
        options: {
          presets: ['@babel/preset-env']
        }
      }
    }
  ]
}
```

2. [DllPlugin](https://webpack.docschina.org/plugins/dll-plugin/)

第三方库，CommonsChunkPlugin 每次构建时都会重新构建一次 vendor，这样效率就降低了。

DllPlugin 是基于 Windows 动态链接库（dll）的思想被创作出来的。这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包。

3. [Happypack](https://github.com/amireh/happypack)

webpack 是单线程的，就算此刻存在多个任务，只能排队一个接一个地等待处理。Happypack 把任务分解给多个子进程去并发执行，大大提高打包效率。

可以为不同的类型/转换定义多个 HappyPack 插件，只需要给每个插件传递唯一的 `id`。

```js
// @file webpack.config.js
const HappyPack = require('happypack');
exports.plugins = [
  new HappyPack({
    id: 'jsx',
    threads: 4,
    loaders: [ 'babel-loader' ]
  }),

  new HappyPack({
    id: 'styles',
    threads: 2,
    loaders: [ 'style-loader', 'css-loader', 'less-loader' ]
  })
];

exports.module.rules = [
  {
    test: /\.js$/,
    use: 'happypack/loader?id=jsx'
  },

  {
    test: /\.less$/,
    use: 'happypack/loader?id=styles'
  },
]
```

### 更合理的打包和压缩文件

1. 拆分资源 `CommonsChunkPlugin`
2. 通过 `Tree-Shaking` 删除冗余代码
3. 使用 `UglifyJsPlugin` 压缩并删除冗余代码（console、注释等）

```js
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
module.exports = {
 plugins: [
   new UglifyJsPlugin({
     // 允许并发
     parallel: true,
     // 开启缓存
     cache: true,
     compress: {
       // 删除所有的console语句    
       drop_console: true,
       // 把使用多次的静态值自动定义为变量
       reduce_vars: true,
     },
     output: {
       // 不保留注释
       comment: false,
       // 使输出的代码尽可能紧凑
       beautify: false
     }
   })
 ]
}
```

4. 按需加载

Vue 构建一个单页应用，用 vue-router 来控制路由，十个路由对应了十个页面。这些页面并不需要一次性加载完，所以可以按需加载。当需要某个页面的时候，再对它进行加载。

这是一个异步的方法，webpack 在打包时，每个会被单独打成一个文件，只有在我们跳转某个这个路由的时候，才会真正地去获取的内容。这就是按需加载。

## HTTP 开启压缩

前面是 webpack 的事，日常开发中，还有一个操作就是在 HTTP 请求的时候开启 gzip 压缩。HTTP 压缩就是以缩小体积为目的，对 HTTP 内容进行重新编码的过程。

> HTTP 压缩是一种内置到网页服务器和网页客户端中以改进传输速度和带宽利用率的方式。在使用 HTTP 压缩的情况下，HTTP 数据在从服务器发送前就已压缩：兼容的浏览器将在下载所需的格式前宣告支持何种方法给服务器；不支持压缩方法的浏览器将下载未经压缩的数据。最常见的压缩方案包括 gzip 和 Deflate。

gzip 的内核就是 Deflate，目前我们压缩文件用得最多的就是 gzip。可以说，gzip 就是 HTTP 压缩的经典例题。

### HTTP 如何支持压缩文件的传输

1. 浏览器请求数据时，通过 `Accept-Encoding` 说明自己可以接受的压缩方法
2. 服务端接收到请求后，选取 `Accept-Encoding` 中的一种对响应数据进行压缩
3. 服务端返回响应数据时，在 `Content-Encoding` 字段中说明数据的压缩方式
4. 浏览器接收到响应数据后根据 `Content-Encoding` 对结果进行解压

注：如果服务器没有对响应数据进行压缩，则不返回Content-Encoding，浏览器也不进行解压

### 要不要使用 gzip

首先要承认 gzip 是高效的，压缩后**通常**能帮我们减少响应 70% 左右的大小。但是也要注意到**服务器压缩 gzip 需要时间，浏览器解压 gzip 也需要时间**，压缩解压的时间和节约的传输时间相比，是否值得？

如果项目是 1k、2k 的小文件，那不值当，压缩之后大小并没有改变多少。但更多的时候，我们处理的都是具备一定规模的项目文件。实践证明，这种情况下压缩和解压带来的时间开销相对于传输过程中节省下的时间开销来说，可以说是微不足道的。

### 配置

Nginx 的 [ngx_http_gzip_module](http://nginx.org/en/docs/http/ngx_http_gzip_module.html) 也提供了开启 GZIP 压缩的方式，下面是一个配置：

```
# 开启gzip
gzip on;

# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩
gzip_min_length 1k;

# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明
gzip_comp_level 2;

# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。
gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript;
```

浏览器在请求资源的时候再 header 里面带上 accept-encoding: gzip 的参数。Nginx 在接收到 Header 之后，发现如果有这个配置，则发送 GZIP 之后的文件（返回的 header 里也包含相关的说明），如果没有则发送源文件。浏览器根据 response header 来处理要不要针对返回的文件进行解压缩然后展示。

## 参考

- [简单聊聊 GZIP 的压缩原理与日常应用](https://juejin.im/post/5b793126f265da43351d5125)
- [探索HTTP传输中gzip压缩的秘密](https://segmentfault.com/a/1190000012800222)
- [「简明性能优化」双端开启Gzip指南](https://juejin.im/post/5cb7ee0e51882532fe3440ea)