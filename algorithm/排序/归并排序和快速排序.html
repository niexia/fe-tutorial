<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>归并排序和快速排序 | fe-tutorial</title>
    <meta name="description" content="前端学习笔记">
    <link rel="icon" href="/fe-tutorial/favicon.ico">
    
    <link rel="preload" href="/fe-tutorial/assets/css/0.styles.91d804f8.css" as="style"><link rel="preload" href="/fe-tutorial/assets/js/app.18c76260.js" as="script"><link rel="preload" href="/fe-tutorial/assets/js/2.6a97cef8.js" as="script"><link rel="preload" href="/fe-tutorial/assets/js/51.770b4c34.js" as="script"><link rel="prefetch" href="/fe-tutorial/assets/js/10.4a9beada.js"><link rel="prefetch" href="/fe-tutorial/assets/js/11.58387187.js"><link rel="prefetch" href="/fe-tutorial/assets/js/12.f4ad3825.js"><link rel="prefetch" href="/fe-tutorial/assets/js/13.7d16a86c.js"><link rel="prefetch" href="/fe-tutorial/assets/js/14.823f9918.js"><link rel="prefetch" href="/fe-tutorial/assets/js/15.b4a75176.js"><link rel="prefetch" href="/fe-tutorial/assets/js/16.7e8c99da.js"><link rel="prefetch" href="/fe-tutorial/assets/js/17.3087208c.js"><link rel="prefetch" href="/fe-tutorial/assets/js/18.d3a5e6c6.js"><link rel="prefetch" href="/fe-tutorial/assets/js/19.6d7517f3.js"><link rel="prefetch" href="/fe-tutorial/assets/js/20.6d47a981.js"><link rel="prefetch" href="/fe-tutorial/assets/js/21.ce4ea7e0.js"><link rel="prefetch" href="/fe-tutorial/assets/js/22.0c4b2c3f.js"><link rel="prefetch" href="/fe-tutorial/assets/js/23.eba265b4.js"><link rel="prefetch" href="/fe-tutorial/assets/js/24.11d3e80a.js"><link rel="prefetch" href="/fe-tutorial/assets/js/25.58e1e97f.js"><link rel="prefetch" href="/fe-tutorial/assets/js/26.6cda6c88.js"><link rel="prefetch" href="/fe-tutorial/assets/js/27.05ce6a8c.js"><link rel="prefetch" href="/fe-tutorial/assets/js/28.68134f72.js"><link rel="prefetch" href="/fe-tutorial/assets/js/29.d7ab2951.js"><link rel="prefetch" href="/fe-tutorial/assets/js/3.fa740a60.js"><link rel="prefetch" href="/fe-tutorial/assets/js/30.38b7ba27.js"><link rel="prefetch" href="/fe-tutorial/assets/js/31.e6d7a763.js"><link rel="prefetch" href="/fe-tutorial/assets/js/32.598b65e8.js"><link rel="prefetch" href="/fe-tutorial/assets/js/33.bd4217d3.js"><link rel="prefetch" href="/fe-tutorial/assets/js/34.1a328f4e.js"><link rel="prefetch" href="/fe-tutorial/assets/js/35.cdff2aab.js"><link rel="prefetch" href="/fe-tutorial/assets/js/36.b850bd1d.js"><link rel="prefetch" href="/fe-tutorial/assets/js/37.46e13c08.js"><link rel="prefetch" href="/fe-tutorial/assets/js/38.e06d4f35.js"><link rel="prefetch" href="/fe-tutorial/assets/js/39.f281db57.js"><link rel="prefetch" href="/fe-tutorial/assets/js/4.b517b399.js"><link rel="prefetch" href="/fe-tutorial/assets/js/40.f7ae19c2.js"><link rel="prefetch" href="/fe-tutorial/assets/js/41.eb25a360.js"><link rel="prefetch" href="/fe-tutorial/assets/js/42.88310836.js"><link rel="prefetch" href="/fe-tutorial/assets/js/43.92ceed5d.js"><link rel="prefetch" href="/fe-tutorial/assets/js/44.f1f55880.js"><link rel="prefetch" href="/fe-tutorial/assets/js/45.24c89388.js"><link rel="prefetch" href="/fe-tutorial/assets/js/46.f606dc71.js"><link rel="prefetch" href="/fe-tutorial/assets/js/47.21fe1f50.js"><link rel="prefetch" href="/fe-tutorial/assets/js/48.e70f68b5.js"><link rel="prefetch" href="/fe-tutorial/assets/js/49.5e397cf4.js"><link rel="prefetch" href="/fe-tutorial/assets/js/5.b11b194d.js"><link rel="prefetch" href="/fe-tutorial/assets/js/50.09cf8b0a.js"><link rel="prefetch" href="/fe-tutorial/assets/js/52.cf68d2c1.js"><link rel="prefetch" href="/fe-tutorial/assets/js/53.66d7a35a.js"><link rel="prefetch" href="/fe-tutorial/assets/js/54.9462ec86.js"><link rel="prefetch" href="/fe-tutorial/assets/js/55.11d45340.js"><link rel="prefetch" href="/fe-tutorial/assets/js/56.b23f0b9e.js"><link rel="prefetch" href="/fe-tutorial/assets/js/57.08ac536f.js"><link rel="prefetch" href="/fe-tutorial/assets/js/58.20bc431d.js"><link rel="prefetch" href="/fe-tutorial/assets/js/59.01200a8e.js"><link rel="prefetch" href="/fe-tutorial/assets/js/6.3a712a3d.js"><link rel="prefetch" href="/fe-tutorial/assets/js/60.8b2adaf3.js"><link rel="prefetch" href="/fe-tutorial/assets/js/61.b874dd62.js"><link rel="prefetch" href="/fe-tutorial/assets/js/62.58e63da8.js"><link rel="prefetch" href="/fe-tutorial/assets/js/63.473e0c0c.js"><link rel="prefetch" href="/fe-tutorial/assets/js/64.ecfe2b77.js"><link rel="prefetch" href="/fe-tutorial/assets/js/65.bf23b9b0.js"><link rel="prefetch" href="/fe-tutorial/assets/js/66.2de1e746.js"><link rel="prefetch" href="/fe-tutorial/assets/js/67.55e09a7c.js"><link rel="prefetch" href="/fe-tutorial/assets/js/68.4fc97859.js"><link rel="prefetch" href="/fe-tutorial/assets/js/69.9d4f3215.js"><link rel="prefetch" href="/fe-tutorial/assets/js/7.6e2bf642.js"><link rel="prefetch" href="/fe-tutorial/assets/js/70.e153d040.js"><link rel="prefetch" href="/fe-tutorial/assets/js/71.e57616cd.js"><link rel="prefetch" href="/fe-tutorial/assets/js/72.e900269e.js"><link rel="prefetch" href="/fe-tutorial/assets/js/73.3f11f04c.js"><link rel="prefetch" href="/fe-tutorial/assets/js/74.95594c7a.js"><link rel="prefetch" href="/fe-tutorial/assets/js/75.a2189eab.js"><link rel="prefetch" href="/fe-tutorial/assets/js/76.9f3661f7.js"><link rel="prefetch" href="/fe-tutorial/assets/js/77.e886f6f9.js"><link rel="prefetch" href="/fe-tutorial/assets/js/78.9b9665d9.js"><link rel="prefetch" href="/fe-tutorial/assets/js/79.3bb4f7a2.js"><link rel="prefetch" href="/fe-tutorial/assets/js/8.e7342a0c.js"><link rel="prefetch" href="/fe-tutorial/assets/js/80.56549118.js"><link rel="prefetch" href="/fe-tutorial/assets/js/81.f1c6bd3a.js"><link rel="prefetch" href="/fe-tutorial/assets/js/82.4bc539f6.js"><link rel="prefetch" href="/fe-tutorial/assets/js/83.f2eedfd7.js"><link rel="prefetch" href="/fe-tutorial/assets/js/84.f8b91b05.js"><link rel="prefetch" href="/fe-tutorial/assets/js/85.eba6a438.js"><link rel="prefetch" href="/fe-tutorial/assets/js/9.ab7c721f.js">
    <link rel="stylesheet" href="/fe-tutorial/assets/css/0.styles.91d804f8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/fe-tutorial/" class="home-link router-link-active"><!----> <span class="site-name">fe-tutorial</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fe-tutorial/dataStructure/" class="nav-link">数据结构</a></div><div class="nav-item"><a href="/fe-tutorial/algorithm/" class="nav-link router-link-active">算法</a></div><div class="nav-item"><a href="/fe-tutorial/javaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/fe-tutorial/webpack/" class="nav-link">Webpack</a></div><div class="nav-item"><a href="https://niexias.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/niexias" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/fe-tutorial/dataStructure/" class="nav-link">数据结构</a></div><div class="nav-item"><a href="/fe-tutorial/algorithm/" class="nav-link router-link-active">算法</a></div><div class="nav-item"><a href="/fe-tutorial/javaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/fe-tutorial/webpack/" class="nav-link">Webpack</a></div><div class="nav-item"><a href="https://niexias.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/niexias" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>算法</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>递归</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algorithm/递归/递归.html" class="sidebar-link">理解递归</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>排序</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algorithm/排序/排序.html" class="sidebar-link">排序算法介绍</a></li><li><a href="/fe-tutorial/algorithm/排序/冒泡、插入和选择排序.html" class="sidebar-link">冒泡、插入和选择排序</a></li><li><a href="/fe-tutorial/algorithm/排序/归并排序和快速排序.html" class="active sidebar-link">归并排序和快速排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe-tutorial/algorithm/排序/归并排序和快速排序.html#归并排序" class="sidebar-link">归并排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe-tutorial/algorithm/排序/归并排序和快速排序.html#归并排序原理" class="sidebar-link">归并排序原理</a></li><li class="sidebar-sub-header"><a href="/fe-tutorial/algorithm/排序/归并排序和快速排序.html#归并排序的性能分析" class="sidebar-link">归并排序的性能分析</a></li></ul></li><li class="sidebar-sub-header"><a href="/fe-tutorial/algorithm/排序/归并排序和快速排序.html#快速排序" class="sidebar-link">快速排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe-tutorial/algorithm/排序/归并排序和快速排序.html#快速排序的原理" class="sidebar-link">快速排序的原理</a></li><li class="sidebar-sub-header"><a href="/fe-tutorial/algorithm/排序/归并排序和快速排序.html#快速排序的性能分析" class="sidebar-link">快速排序的性能分析</a></li></ul></li></ul></li><li><a href="/fe-tutorial/algorithm/排序/桶排序、计数排序和基数排序.html" class="sidebar-link">桶排序、计数排序和基数排序</a></li><li><a href="/fe-tutorial/algorithm/排序/排序优化.html" class="sidebar-link">排序优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>二分查找</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algorithm/二分查找/二分查找.html" class="sidebar-link">二分查找</a></li><li><a href="/fe-tutorial/algorithm/二分查找/二分查找的变形.html" class="sidebar-link">二分查找的变形</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>哈希算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algorithm/哈希算法/哈希算法.html" class="sidebar-link">哈希算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>字符串匹配</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algorithm/字符串匹配/BF算法和RK算法.html" class="sidebar-link">BF 算法和 RK 算法</a></li><li><a href="/fe-tutorial/algorithm/字符串匹配/BM算法.html" class="sidebar-link">/algorithm/字符串匹配/BM算法.html</a></li><li><a href="/fe-tutorial/algorithm/字符串匹配/KMP算法.html" class="sidebar-link">/algorithm/字符串匹配/KMP算法.html</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>贪心算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algorithm/贪心算法/贪心算法.html" class="sidebar-link">贪心算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>分治算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algorithm/分治算法/分治算法.html" class="sidebar-link">分治算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>回溯算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algorithm/回溯算法/回溯算法.html" class="sidebar-link">回溯算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>动态规划</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-tutorial/algorithm/动态规划/动态规划.html" class="sidebar-link">动态规划</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="归并排序和快速排序"><a href="#归并排序和快速排序" aria-hidden="true" class="header-anchor">#</a> 归并排序和快速排序</h1> <p>归并排序和快速排序的时间复杂度都是 O(nlogn) 的排序算法。</p> <h2 id="归并排序"><a href="#归并排序" aria-hidden="true" class="header-anchor">#</a> 归并排序</h2> <p>先看一下归并排序的原理。</p> <h3 id="归并排序原理"><a href="#归并排序原理" aria-hidden="true" class="header-anchor">#</a> 归并排序原理</h3> <p>如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再讲排好序的两部分合并在一起，这样整个数组就有序了。</p> <p><strong>归并排序使用的就是分治思想</strong>。分治，就是分而治之。讲一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。</p> <p>通过上面的描述，感觉分治思想和递归思想很相似。是的，分治算法一般都是用递归来实现的。<strong>分支是一种解决问题的处理思想，递归是一种编程技巧</strong>。</p> <p>为了写出归并排序的代码，先要找到递推公式和终止条件：</p> <div class="language- extra-class"><pre class="language-text"><code>// 递推公式
mergeSort(p...r) = merge(mergeSort(p...q), mergeSort(q+1...r))

// 终止条件
p &gt;= r
</code></pre></div><p>也就是说，给一个下标从 p 到 r 的数组排序，可以转化为两个子问题：<code>mergeSort(p...q)</code> 和<code>mergeSort(q+1...r)</code>，其中 q 为 p 和 r 的中间位置，即 <code>q = (p+r)/2</code>。当两个子数组排好序之后，再将两个有序的子数组合并起来，这样 p 到 r 也就排好序了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arr<span class="token punctuation">;</span>

  <span class="token comment">// 从中间分解</span>
  <span class="token keyword">let</span> middle <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> left <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> right <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>middle<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 定义合并函数</span>
  <span class="token keyword">const</span> <span class="token function-variable function">mergeArr</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> leftIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rightIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 比较两个数组中元素的大小，依次插入到 temp 中</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftIndex <span class="token operator">&lt;</span> left<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> rightIndex <span class="token operator">&lt;</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span>leftIndex<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right<span class="token punctuation">[</span>rightIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>leftIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        leftIndex<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>rightIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        rightIndex<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将剩下元素的放到默认</span>
    temp <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>leftIndex<span class="token punctuation">)</span><span class="token punctuation">,</span> right<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>rightIndex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 递归 分解 合并</span>
  <span class="token keyword">return</span> <span class="token function">mergeArr</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="归并排序的性能分析"><a href="#归并排序的性能分析" aria-hidden="true" class="header-anchor">#</a> 归并排序的性能分析</h3> <h4 id="归并排序是稳定的排序算法吗？"><a href="#归并排序是稳定的排序算法吗？" aria-hidden="true" class="header-anchor">#</a> 归并排序是稳定的排序算法吗？</h4> <p>归并排序稳步稳定关键要看 <code>merge</code> 函数，在合并过程中，如果 A[p...q] 和 A[q+1...r] 之间有相同的值，那么只要先把 A[p...q]的元素先放入，这样就能保证值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p> <h4 id="归并排序的时间复杂度是多少？"><a href="#归并排序的时间复杂度是多少？" aria-hidden="true" class="header-anchor">#</a> 归并排序的时间复杂度是多少？</h4> <p>归并排序是通过递归实现的。递归就是把一个大问题 a 分解成几个小问题 b、c 来求解，求小问题 b、c 解决之后，再把小问题的结果合并成大问题 a 的解。</p> <p>如果我们定义求解大问题的 a 的时间是 T(a)，求解小问题 b、c 的时间分别是 T(b) 和 T(c)，那么局可以得到这样的递推公式：</p> <div class="language- extra-class"><pre class="language-text"><code>T(a) = T(b) + T(c) + K
</code></pre></div><p>其中 K 为将两个子问题 b、c 的结果合并成 a 的结果所消耗的时间。</p> <p>从上面的分析，我们可以得到一个结论：<strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递归公式</strong>。</p> <p>假设对长度为 n 的数组进行归并排序所需要时间是 T(n)，那分解两个子数组排序的时间都是 T(n/2)，而 <code>merge</code> 两个有序子数组的时间复杂度是 O(n)。那么归并排序的时间复杂度的计算公式就是：</p> <div class="language- extra-class"><pre class="language-text"><code>T(n) = 2T(n/2) + n; n &gt; 1
T(1) = C; n = 1，只需要常量级的执行时间，所以表示为 C
</code></pre></div><p>所以就有：</p> <div class="language- extra-class"><pre class="language-text"><code>T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n
     = ...
     = 2^k * T(n/2^k) + k * n
     = ...
</code></pre></div><p>当 T(n/2^k) = 1 时，即 n/2^k = 1 时，就可以得到 k = log2n。把 k 代入表达式就有：</p> <div class="language- extra-class"><pre class="language-text"><code>T(n) = n * C + nlog2n
</code></pre></div><p>用大 O 表示法表示的话 T(n) = O(nlogn)，所以归并排序的时间复杂度就是 <strong><code>T(n) = O(nlogn)</code></strong>。</p> <h4 id="归并排序的空间复杂度是多少？"><a href="#归并排序的空间复杂度是多少？" aria-hidden="true" class="header-anchor">#</a> 归并排序的空间复杂度是多少？</h4> <p>我们知道，在归并排序过程中，在合并的时候需要额外的空间，那归并排序的空间复杂度是多少？O(n) 还是 O(nlogn)，怎样分析？</p> <p>通过时间复杂度的分析过程，如果也按照递归的方式求解，那么就会得到 O(nlogn)，不过这个思路是不对的。实际上，<strong>递归代码的空间复杂度不能像时间复杂度一样进行累加，在任意时刻，CPU 只会有一个函数执行，也就是只有一个临时的内存空间在使用，而这个函数执行完之后，内存空间也被释放掉了</strong>。</p> <p>虽然我们每次合并操作都需要额外的空间，但是合并之后，临时开辟的空间就会释放掉。临时的内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 <strong>O(n)</strong>。</p> <p>所以归并排序不是一个原地排序算法，也正是这样，虽然归并排序的时间复杂度在任何时刻都是 O(nlogn)，非常优秀（快速排序的最坏时间度是 O(n^2)），但是归并排序并没有快排那样，应用广泛。</p> <h2 id="快速排序"><a href="#快速排序" aria-hidden="true" class="header-anchor">#</a> 快速排序</h2> <p>快速排序简称“快排”，它也利用分治思想。</p> <h3 id="快速排序的原理"><a href="#快速排序的原理" aria-hidden="true" class="header-anchor">#</a> 快速排序的原理</h3> <p>快排的原理是：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间任意的一个数据作为 <strong>pivot</strong>（分区点）。然后遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，大于 pivot 的放到右边，将 pivot 放到中间。经过这一个步骤之后，数组 p 到 r 之间的数据就被分成了 3 个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面 q+1 到 r 之间是大于 pivot 的。</p> <p>根据分治、递归的处理思想，接着递归 p 到 q+1 和 q+1 到 r 之间的数据，直到区间缩小为1，就说明数据有序了。</p> <p>上面的过程用递推工时来表示就是：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 递推公式</span>
<span class="token function">quickSort</span><span class="token punctuation">(</span>p<span class="token operator">...</span>r<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>p<span class="token operator">...</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>q<span class="token operator">+</span><span class="token number">1.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">)</span>

<span class="token comment">// 终止条件</span>
p <span class="token operator">&gt;=</span> r
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 交换位置</span>
  <span class="token keyword">const</span> <span class="token function-variable function">swap</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 根据 pivot 进行分区</span>
  <span class="token keyword">const</span> <span class="token function-variable function">partition</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> pivot<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> pivotVal <span class="token operator">=</span> arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 通过 i 把数组分成两个部分，左边是已处理区间，每次</span>
    <span class="token comment">// 从未处理区间取一个取一个元素来进行比较</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivotVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> pivot<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> <span class="token function-variable function">_quickSort</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> pivot <span class="token operator">=</span> right<span class="token punctuation">;</span>
    <span class="token keyword">let</span> partitionIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> partitionIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> partitionIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>设计原地分区函数，如果不考虑空间消耗，申请两个临时数组 X 和 Y，遍历 A[p...r]，将小于 pivot 的放到 X，大于 pivot 的放到 Y，最后再将 X 和 Y数据拷贝到 A[p...r]。但是这样实现的话，快排就需要额外的空间了。通过巧妙的设计原地分区函数，使得空间复杂度为 O(1)，使得<strong>快排是原地排序算法</strong>。</p> <p>在执行分区的时候，如果数组有两个相同的元素，比如序列 6, 8, 7, 6, 3, 5, 9, 4，在经过第一次分区操作之后，两个 6 相对的先后顺序就会改变，所以<strong>快速排序不是稳定的排序算法</strong>。</p> <p>通过上面的分析发现：<strong>归并排序的处理过程是下到上，先处理子问题，然后在合并。而快排正好相反，它的处理过程是由上到下，先分区，再处理子问题。</strong></p> <p>归并排序虽然稳定的、时间复杂度为 O(nlogn)，但是在合并的时候需要临时的空间，所以是非原地排序。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p> <h3 id="快速排序的性能分析"><a href="#快速排序的性能分析" aria-hidden="true" class="header-anchor">#</a> 快速排序的性能分析</h3> <p>通过前面的原理，已经知道快排是一种原地、不稳定的排序算法。现在看看快排的时间复杂度。</p> <p>快排也是递归来实现了，所以前面总结的公式还适用：</p> <div class="language- extra-class"><pre class="language-text"><code>T(n) = 2T(n/2) + n; n &gt; 1
T(1) = C; n = 1
</code></pre></div><p>这时快排的时间复杂度是 O(nlogn)，但<strong>前提是</strong>每次分区操作选择的 pivot 都很合适，能将数组分成大小接近相等的两个小区间。这是很难实现的。</p> <p>举一个极端的例子，例如数组中的数据原来已经有序了：1, 2, 3, 4, 5，如果每次都选最优一个元素作为 pivot，那么每次分区得到的两个区间都是不均等的。需要大约 n 次分区操作，才能完成快排操作，这个时候递推公式变为：</p> <div class="language- extra-class"><pre class="language-text"><code>T(n) = T(n-1) + n;
</code></pre></div><p>这个时候，时间复杂度就又 O(nlogn) 退化成 O(n^2)。</p> <p>所以<strong>快排在大部分的情况下时间复杂度都是 O(nlogn)，只有在极端情况下才会退化到 O(n^2)</strong>。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">10/23/2019, 12:07:06 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/fe-tutorial/algorithm/排序/冒泡、插入和选择排序.html" class="prev">冒泡、插入和选择排序</a></span> <span class="next"><a href="/fe-tutorial/algorithm/排序/桶排序、计数排序和基数排序.html">桶排序、计数排序和基数排序</a>→
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/fe-tutorial/assets/js/app.18c76260.js" defer></script><script src="/fe-tutorial/assets/js/2.6a97cef8.js" defer></script><script src="/fe-tutorial/assets/js/51.770b4c34.js" defer></script>
  </body>
</html>
