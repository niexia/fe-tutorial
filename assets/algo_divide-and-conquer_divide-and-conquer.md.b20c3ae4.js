import{_ as e,r as a,o as n,c as l,a as s,b as i,d as r,e as p}from"./app.31755bf0.js";const d=JSON.parse('{"title":"分治算法","description":"","frontmatter":{},"headers":[{"level":2,"title":"如何理解分治算法","slug":"如何理解分治算法","link":"#如何理解分治算法","children":[]},{"level":2,"title":"应用","slug":"应用","link":"#应用","children":[{"level":3,"title":"指导编码，如何求有序度或逆序度","slug":"指导编码-如何求有序度或逆序度","link":"#指导编码-如何求有序度或逆序度","children":[]},{"level":3,"title":"在海量数据处理中的应用","slug":"在海量数据处理中的应用","link":"#在海量数据处理中的应用","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"relativePath":"algo/divide-and-conquer/divide-and-conquer.md"}'),t={name:"algo/divide-and-conquer/divide-and-conquer.md"},o=i("h1",{id:"分治算法",tabindex:"-1"},[r("分治算法 "),i("a",{class:"header-anchor",href:"#分治算法","aria-hidden":"true"},"#")],-1),c=p('<p>MapReduce 是 Google 大数据处理的三驾马车之一，尽管开发一个 MapReduce 看起来很高深，感觉跟我们遥不可及。实际上，万变不离其宗，它的本质分治算法。</p><h2 id="如何理解分治算法" tabindex="-1">如何理解分治算法 <a class="header-anchor" href="#如何理解分治算法" aria-hidden="true">#</a></h2><p>分治算法（divide and conquer）的核心思想其实就是四个字：<strong>分而治之</strong> 。也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>这个定义看起来有点类似递归的定义。关于分治和递归的区别，<strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>。</p><p>实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，<strong>每一层递归都会涉及这样三个操作</strong>：</p><ul><li>分解：将原问题分解成一系列子问题；</li><li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li><li>合并：将子问题的结果合并成原问题。</li></ul><p><strong>分治算法能解决的问题，一般需要满足下面这几个条件</strong>：</p><ul><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li></ul><h2 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-hidden="true">#</a></h2><h3 id="指导编码-如何求有序度或逆序度" tabindex="-1">指导编码，如何求有序度或逆序度 <a class="header-anchor" href="#指导编码-如何求有序度或逆序度" aria-hidden="true">#</a></h3><p>在排序算法说到，用有序度来表示一组数据的有序程度，用逆序度表示一组数据的无序程度。知道完全有序的数据的有序度就是 n * (n-1)/2，逆序度为 0。</p><p>那如何编程求出一组数据的有序对个数或者逆序对个数呢？</p><p>有序对和逆序对的求解方式都是相似的，这里只看一下逆序度对个数的求解过程。</p><ul><li>最笨的方法</li></ul><p>最笨的方法，拿每个数字跟它后面的数字比较，看有几个比它小的。把比它小的数字的个数记为 k。通过这种方式，对每个数字都考察一遍，最后将每个数字对应的 k 值求和，得到的就是逆序对个数。不过这种操作次数是：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">S = n-1 + n-2 + ... + 1 </span></span>\n<span class="line"><span style="color:#A6ACCD;">  = (n-1 + 1)(n - 1)/2 </span></span>\n<span class="line"><span style="color:#A6ACCD;">  = n(n-1)/2，</span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>所以时间复杂度为 O(n^2)。</p><ul><li>借助归并排序算法</li></ul><p>归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。<strong>在这个合并的过程中，就可以计算这两个小数组的逆序对个数了</strong>。</p><p><img src="/fe-tutorial/assets/algorithm-divideAndConquerAlgorithms-eg1.3b06cb21.png" alt="divide and conquer algorithms eg1"></p><h3 id="在海量数据处理中的应用" tabindex="-1">在海量数据处理中的应用 <a class="header-anchor" href="#在海量数据处理中的应用" aria-hidden="true">#</a></h3><p>分治算法不仅限于指导编程和算法设计，还经常用在海量数据处理的场景中。</p><p>对于基于基于内存存储和单机处理的数据结构和算法，如果要处理的数据量非常大，<strong>没法一次性放到内存中</strong>，这个时候，这些数据结构和算法就无法工作了。</p><p>比如，给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而我们的机器的内存可能只有 2、3GB 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。</p><p><strong>可以分治的思想，可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。</strong></p><p>实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。</p><p>要给 10GB 的订单排序，线性排序的桶排序也介绍过，我们可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。</p><p>这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><p>解答开篇问题，为什么说 MapReduce 的本质就是分治思想？</p><p>刚刚举的订单的例子，数据有 10GB 大小，可能给你的感受还不强烈。那如果我们要处理的数据是 1T、10T、100T 这样子的，那一台机器处理的效率肯定是非常低的。而对于谷歌搜索引擎来说，网页爬取、清洗、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据（比如网页）。所以，利用<strong>集群</strong>并行处理显然是大势所趋。</p><p>一台机器过于低效，那我们就把任务拆分到多台机器上来处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并。这不就是分治思想吗？</p><p>实际上，MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。</p>',33);const h=e(t,[["render",function(e,i,r,p,d,t){const h=a("VueJobs");return n(),l("div",null,[o,s(h),c])}]]);export{d as __pageData,h as default};
