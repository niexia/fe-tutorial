import{_ as s,r as n,o as a,c as p,a as l,b as e,d as i,e as t}from"./app.a6773dcb.js";const o=JSON.parse('{"title":"跳表","description":"","frontmatter":{},"headers":[{"level":2,"title":"理解跳表","slug":"理解跳表","link":"#理解跳表","children":[{"level":3,"title":"时间复杂度","slug":"时间复杂度","link":"#时间复杂度","children":[]},{"level":3,"title":"空间复杂度","slug":"空间复杂度","link":"#空间复杂度","children":[]},{"level":3,"title":"高效的插入和删除","slug":"高效的插入和删除","link":"#高效的插入和删除","children":[]}]},{"level":2,"title":"跳表的动态性","slug":"跳表的动态性","link":"#跳表的动态性","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[{"level":3,"title":"解答开篇","slug":"解答开篇","link":"#解答开篇","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]}]}],"relativePath":"algo/skip-list/skip-list.md"}'),r={name:"algo/skip-list/skip-list.md"},g=e("h1",{id:"跳表",tabindex:"-1"},[i("跳表 "),e("a",{class:"header-anchor",href:"#跳表","aria-hidden":"true"},"#")],-1),c=t('<p>跳表是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除和查找操作。在二分查找的时候，说到它不能使用链表，实际上，将它改造为跳表，就可以支持类似“二分”的查找算法。</p><p>Redis 中的有序集合（Sorted Set）就是用跳表来实现的。如果你有一定基础，应该知道红黑树也可以实现快速的插入、删除和查找操作。那 Redis 为什么会选择用跳表来实现有序集合呢？ 为什么不用红黑树呢？</p><h2 id="理解跳表" tabindex="-1">理解跳表 <a class="header-anchor" href="#理解跳表" aria-hidden="true">#</a></h2><p>对于单链表来说，即便存储的数据是有序的，也只能通过遍历来查找某个数据。查找的时间复杂度为 O(n)，效率并不高。</p><p><img src="/fe-tutorial/assets/dataStructure-skipList-linked.8a6364a0.png" alt="skipList-linked"></p><p>单链表查询慢是因为需要从头遍历，那么对链表建立一级<strong>索引</strong>，查找就会快起来。这里每两个结点取一个到上一级，把抽出来的这一级叫作<strong>索引</strong>或者<strong>索引层</strong>。其中，down 表示 down 指针，指向下一级结点。</p><p><img src="/fe-tutorial/assets/dataStructure-skipList-oneLay.deb61128.png" alt="skipList-oneLay"></p><p>如果我们要查找值为 14 这个结点，通过单链表，<strong>需要遍历 10 个结点</strong>。</p><p>而使用了跳表之后，可以现在索引层遍历，当遍历到值为 13 的这个结点时，我们发现下一个结点值为 15，所以 14 肯定在这两个结点之间。通过 down 指针，下降到原始数据这一层，继续遍历，这个时候只需要遍历 2 个结点，就找到值为 14 的结点了。<strong>总共遍历 7 个结点</strong>。</p><p>也就说，<strong>加了一层索引层之后，查找一个结点需要遍历的结点少了，效率提高了</strong>。</p><p>跟前面类似，可以依次在索引上继续增加索引层。</p><p><img src="/fe-tutorial/assets/dataStructure-skipList-twoLays.d16e30fb.png" alt="skipList-twoLays"></p><p>加了第二级所以之后，现在只<strong>需要遍历 6 个结点</strong>。</p><p>这里数据量不大，所以提升的效率不是很明显。当链表的长度为 100、1000 等，通过构建索引，查询效率会得到极大的提升。</p><p><strong>这种链表加多级索引的结构，就是跳表。</strong></p><p><img src="/fe-tutorial/assets/dataStructure-skipList-threeLays.127945fc.png" alt="skipList-threeLays"></p><h3 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-hidden="true">#</a></h3><p>通过添加索引层，可以提高查询的效率。下面算一下跳表的时间复杂度。</p><p>上面简历索引是每 2 个结点抽出一个作为上一级的索引结点。所以有：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">// 第一级索引的结点个数大约</span></span>\n<span class="line"><span style="color:#A6ACCD;">n/2</span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span>\n<span class="line"><span style="color:#A6ACCD;">// 第二级索引的结点个数大约</span></span>\n<span class="line"><span style="color:#A6ACCD;">n/4</span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span>\n<span class="line"><span style="color:#A6ACCD;">// 第三级索引的结点个数大约</span></span>\n<span class="line"><span style="color:#A6ACCD;">n/8</span></span>\n<span class="line"><span style="color:#A6ACCD;">...</span></span>\n<span class="line"><span style="color:#A6ACCD;">// 第k级索引的结点个数大约</span></span>\n<span class="line"><span style="color:#A6ACCD;">n/2^k</span></span>\n<span class="line"><span style="color:#A6ACCD;">...</span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>现在总共有 h 级索引，而<strong>最高级索引有 2 个结点</strong>。那么就有 n/2^h = 2，h = log2n - 1。如果包含原始数据这层，<strong>整个跳表的高度就是 log2n</strong>。</p><p>现在查找某个数据，如果每层需要遍历 m 个结点，那么跳表查询一个数据的时间复杂度就是 O(m * log2n)，即 O(m * logn)。</p><p>现在只需要知道 m 是多少就可以知道时间复杂度了。</p><p>跳表的某一级索引都是在下一级的每 2 个结点抽出一个结点组成的。所以当我们从 k 级降到 k-1 级，<strong>在 k-1 级最多遍历不会超过 3 个结点</strong>。得到 m = 3。</p><p>最后就得到<strong>跳表的时间复杂度就是 O(logn)</strong>。非常高效，时间复杂度和二分查找一样，也就是说基于单链表实现了二分查找。</p><h3 id="空间复杂度" tabindex="-1">空间复杂度 <a class="header-anchor" href="#空间复杂度" aria-hidden="true">#</a></h3><p>跳表是通过建立索引来提升效率，以空间换时间。分析以下它的空间复杂度。</p><p>原始链表长度为 n，每 2 个节点抽 1 个，那么第一级索引大约需要 n/2 个结点，第二级大约需要 n/4 个结点，...，最高一级需要 2 个结点。所以每一级需要的节点如下：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">n/2, n/4, n/8, ..., 8, 4, 2</span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>这是一个等比数列，根据等比数列的求和公式：</p><p><img src="data:image/png;base64,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" alt="math"></p><p>可以求得需要的总结点数为 Sn = n - 2，所以<strong>跳表的空间复杂度是 O(n)</strong>。</p><p>上面都是每 2 个结点抽一个到上级作为索引，那如果每 3 个或者每 5 个呢？</p><p><strong>以每 3 个结点抽一个再分析一遍</strong>：</p><ol><li>的时间复杂度</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">n/3, n/9, ..., n/3^k, ...</span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>总共有 h 级，那么 n/3^h = 3，h = log3n - 1，每一级最多遍历 4 个结点所以时间复杂度为 O(4*(log3n-1))，即 O(logn)。</p><ol start="2"><li>空间复杂度</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">n/3, n/9, ..., 9, 3, 1</span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>根据等比数列的求和 Sn = n/2。尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。</p><p>实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，<strong>所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了</strong>。</p><h3 id="高效的插入和删除" tabindex="-1">高效的插入和删除 <a class="header-anchor" href="#高效的插入和删除" aria-hidden="true">#</a></h3><p>跳表是个动态的数据结构，不仅支持查询，还支持动态的插入和删除。而且插入和删除的复杂度也是 O(logn)。</p><p>单链表的插入和删除操作复杂度都是 O(1)，而跳表的查找某个结点时间复杂度是 O(logn)，现在要查找某个数据应该插入和删除的位置，要找到前驱结点，方法也类似，所以时间复杂度是 O(logn)。</p><p>值得注意的时，删除某个结点时，如果这个节点也存在于索引中，那么还要将索引中的结点删除。</p><h2 id="跳表的动态性" tabindex="-1">跳表的动态性 <a class="header-anchor" href="#跳表的动态性" aria-hidden="true">#</a></h2><p>当我们不停的向跳表中插入数据，如果不更新索引，就可能出现 2 个索引节点之间的数据非常多的情况。极端情况下，跳表还会退化为单链表。</p><p><img src="/fe-tutorial/assets/dataStructure-skipList-multipleInsert.47bdfd4a.png" alt="multipleInsert"></p><p>为了避免退化，保持索引和原始链表大小之间的平衡，那么链表结点增加了，索引结点也需要增加。</p><p><strong>跳表是通过随机函数来维护这个平衡的</strong>。通过一个随机函数，来决定将这个结点插入到哪几级索引。比如，<strong>随机生成函数生成 k，那么就将节点插入 1~k 级这 k 级索引中</strong>。</p><p>随机函数，从概率上保证跳表的索引和数据的大小平衡。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><h3 id="解答开篇" tabindex="-1">解答开篇 <a class="header-anchor" href="#解答开篇" aria-hidden="true">#</a></h3><p>先解答开篇，Redis 为什么会选择用跳表来实现有序集合呢？</p><p>Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。我们知道Redis 中的有序集合支持的核心操作主要有下面这几个：</p><ul><li>插入一个数据；</li><li>删除一个数据；</li><li>查找一个数据；</li><li>按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；</li><li>迭代输出有序序列。</li></ul><p>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。<strong>但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高</strong>。</p><p>对于按照区间查找数据这个操作，<strong>跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了</strong>。这样做非常高效。</p><p>当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。</p><p>还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-hidden="true">#</a></h3><p>跳表这种数据结构使用的是空间换时间的思路，通过构建多级索引来提高查询效率，实现了基于链表的“二分查找”（时间复杂度是 O(logn)）。</p><p>跳表是一种动态的数据结构，支持快速插入、删除和查找操作，<strong>时间复杂度都是 O(logn)</strong>。</p><p>跳表作为一种数据结构，它需要额外的存储空间来存储索引层，<strong>空间复杂度是 O(n)</strong>。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p><p>虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，倾向用跳表。</p>',65);const d=s(r,[["render",function(s,e,i,t,o,r){const d=n("VueJobs");return a(),p("div",null,[g,l(d),c])}]]);export{o as __pageData,d as default};
