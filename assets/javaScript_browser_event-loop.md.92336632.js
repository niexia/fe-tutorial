import{_ as s,r as n,o as a,c as l,a as o,b as p,d as e,e as t}from"./app.a6773dcb.js";const c=JSON.parse('{"title":"Event Loop","description":"","frontmatter":{},"headers":[{"level":2,"title":"浏览器的 EventLoop","slug":"浏览器的-eventloop","link":"#浏览器的-eventloop","children":[{"level":3,"title":"任务队列","slug":"任务队列","link":"#任务队列","children":[]},{"level":3,"title":"事件和回调函数","slug":"事件和回调函数","link":"#事件和回调函数","children":[]},{"level":3,"title":"Event Loop","slug":"event-loop-1","link":"#event-loop-1","children":[]},{"level":3,"title":"宏任务与微任务","slug":"宏任务与微任务","link":"#宏任务与微任务","children":[]},{"level":3,"title":"看一道题目","slug":"看一道题目","link":"#看一道题目","children":[]},{"level":3,"title":"结合前面的线程再看看","slug":"结合前面的线程再看看","link":"#结合前面的线程再看看","children":[]}]},{"level":2,"title":"Node 环境的 EventLoop","slug":"node-环境的-eventloop","link":"#node-环境的-eventloop","children":[{"level":3,"title":"同步任务和异步任务","slug":"同步任务和异步任务","link":"#同步任务和异步任务","children":[]},{"level":3,"title":"本轮循环和次轮循环","slug":"本轮循环和次轮循环","link":"#本轮循环和次轮循环","children":[]},{"level":3,"title":"process.nextTick()","slug":"process-nexttick","link":"#process-nexttick","children":[]},{"level":3,"title":"微任务","slug":"微任务","link":"#微任务","children":[]},{"level":3,"title":"事件循环的概念","slug":"事件循环的概念","link":"#事件循环的概念","children":[]},{"level":3,"title":"事件循环的六个阶段","slug":"事件循环的六个阶段","link":"#事件循环的六个阶段","children":[]},{"level":3,"title":"setTimeout 和 setImmediate","slug":"settimeout-和-setimmediate","link":"#settimeout-和-setimmediate","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"relativePath":"javaScript/browser/event-loop.md"}'),r={name:"javaScript/browser/event-loop.md"},i=p("h1",{id:"event-loop",tabindex:"-1"},[e("Event Loop "),p("a",{class:"header-anchor",href:"#event-loop","aria-hidden":"true"},"#")],-1),y=t('<p>JS 执行是单线程的，这也意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。而这种机制基于事件循环来实现的。</p><h2 id="浏览器的-eventloop" tabindex="-1">浏览器的 EventLoop <a class="header-anchor" href="#浏览器的-eventloop" aria-hidden="true">#</a></h2><h3 id="任务队列" tabindex="-1">任务队列 <a class="header-anchor" href="#任务队列" aria-hidden="true">#</a></h3><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p><p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候CPU是闲着的，因为 IO 设备（输入输出设备）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。</p><p>JavaScrip t语言的设计者意识到，这时主线程完全可以不管IO设备，<strong>挂起处于等待中的任务，先运行排在后面的任务</strong>。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）</li><li>主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</li><li>一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><p>下图就是主线程和任务队列的示意图：</p><p><img src="/fe-tutorial/assets/javascript-browser-EventLoop-taskQueue.025b9708.jpg" alt="Task Queue"></p><h3 id="事件和回调函数" tabindex="-1">事件和回调函数 <a class="header-anchor" href="#事件和回调函数" aria-hidden="true">#</a></h3><p>&quot;任务队列&quot;是一个事件的队列（也可以理解成消息的队列），IO 设备完成一项任务，<strong>就在&quot;任务队列&quot;中添加一个事件，表示相关的异步任务可以进入&quot;执行栈&quot;了</strong>。主线程读取&quot;任务队列&quot;，就是读取里面有哪些事件。</p><p>&quot;任务队列&quot;中的事件，除了 IO 设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入&quot;任务队列&quot;，等待主线程读取。</p><p>所谓&quot;回调函数&quot;（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p><p>&quot;任务队列&quot;是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，&quot;任务队列&quot;上第一位的事件就自动进入主线程。但是，由于存在&quot;定时器&quot;功能，可以放置定时事件，就是 <code>setTimeout</code> 和 <code>setInterval</code>，主线程首先要检查一下执行时间，只有到了规定的时间，才能返回主线程。</p><h3 id="event-loop-1" tabindex="-1">Event Loop <a class="header-anchor" href="#event-loop-1" aria-hidden="true">#</a></h3><p>主线程从&quot;任务队列&quot;中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p><p>为了更好地理解Event Loop，请看下图（转引自Philip Roberts的演讲《Help, I&#39;m stuck in an event-loop》）。</p><p><img src="/fe-tutorial/assets/javascript-browser-EventLoop.c02ab728.jpg" alt="EventLoop"></p><p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在&quot;任务队列&quot;中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取&quot;任务队列&quot;，依次执行那些事件所对应的回调函数。</p><p>值得注意的是，任务队列的所有任务并不是怪怪排队的。</p><h3 id="宏任务与微任务" tabindex="-1">宏任务与微任务 <a class="header-anchor" href="#宏任务与微任务" aria-hidden="true">#</a></h3><p>异步任务也存在优先级，把异步任务分为两类：<strong>微任务</strong>（micro task）和<strong>宏任务</strong>（macro task）。常见的有：</p><ul><li>Task(macroTask): setTimeout, setInterval, setImmediate, I/O, UI rendering。</li><li>microTask: Promise, process.nextTick, Object.observe, MutationObserver。</li></ul><p>针对这两种任务类型，任务队列实际上也对应有微任务队列和宏任务队列。当主线程执行栈为空时，主线程先查看微任务队列是否有事件存在：</p><ol><li>如果有事件存在，<strong>会依次执行队列中事件对应的回调，直到微任务队列为空</strong>。然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈。</li><li>如果事件不存在，则再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈。</li></ol><p>需要记住<strong>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>。</p><h3 id="看一道题目" tabindex="-1">看一道题目 <a class="header-anchor" href="#看一道题目" aria-hidden="true">#</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">script start</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">setTimeout</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">promise1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">promise2</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">script end</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>输出的顺序是：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">script start</span></span>\n<span class="line"><span style="color:#A6ACCD;">script end</span></span>\n<span class="line"><span style="color:#A6ACCD;">promise1</span></span>\n<span class="line"><span style="color:#A6ACCD;">promise2</span></span>\n<span class="line"><span style="color:#A6ACCD;">setTimeout</span></span>\n<span class="line"></span></code></pre></div><p>因为 <code>Promise</code> 是微任务，执行会优先于 <code>setTimeout</code>。</p><h3 id="结合前面的线程再看看" tabindex="-1">结合前面的线程再看看 <a class="header-anchor" href="#结合前面的线程再看看" aria-hidden="true">#</a></h3><p>在整个循环中，需要这些线程：</p><ol><li>JS 引擎线程：主线程，执行任务。</li><li>事件触发线程：事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>定时触发器线程：定时计数器并不是由 JavaScript 引擎计数的，因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确。所以通过定时触发器线程来触发定时并计时，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行。</li></ol><h2 id="node-环境的-eventloop" tabindex="-1">Node 环境的 EventLoop <a class="header-anchor" href="#node-环境的-eventloop" aria-hidden="true">#</a></h2><p>在 node 中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node 中事件循环的实现是依靠的 libuv 引擎。我们知道 node 选择 chrome v8 引擎作为 js 解释器，v8 引擎将 js 代码分析后去调用对应的node api，而这些api最后则由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上 node 中的事件循环存在于 libuv 引擎中。</p><p>为了协调异步任务，Node 居然提供了四个定时器，让任务可以在指定的时间运行。</p><ul><li>setTimeout()</li><li>setInterval()</li><li>setImmediate()</li><li>process.nextTick()</li></ul><p>先看一段代码，它的运行结果是多少呢？</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// test.js</span></span>\n<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">nextTick</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">4</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;">))()</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>运行结果如下：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">node test.js</span></span>\n<span class="line"><span style="color:#A6ACCD;">5</span></span>\n<span class="line"><span style="color:#A6ACCD;">3</span></span>\n<span class="line"><span style="color:#A6ACCD;">4</span></span>\n<span class="line"><span style="color:#A6ACCD;">1</span></span>\n<span class="line"><span style="color:#A6ACCD;">2</span></span>\n<span class="line"></span></code></pre></div><p>为什么是这样，接下来看看 Node 怎么处理各种定时器，或者更广义地说，libuv 库怎么安排异步任务在主线程上执行，它和浏览器的 EventLoop 有什么不同。</p><h3 id="同步任务和异步任务" tabindex="-1">同步任务和异步任务 <a class="header-anchor" href="#同步任务和异步任务" aria-hidden="true">#</a></h3><p>首先，同步任务总是比异步任务更早执行。所以前面那段代码，下面这行最先执行：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;">))()</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><h3 id="本轮循环和次轮循环" tabindex="-1">本轮循环和次轮循环 <a class="header-anchor" href="#本轮循环和次轮循环" aria-hidden="true">#</a></h3><p>异步任务可以分成<strong>两种</strong>：</p><ul><li>追加在本轮循环的异步任务</li><li>追加在次轮循环的异步任务</li></ul><p>所谓&quot;循环&quot;，指的是事件循环（event loop）。</p><p><strong>Node 规定，process.nextTick 和 Promise 的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而 setTimeout、setInterval、setImmediate 的回调函数，追加在次轮循环。</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// 下面两行，次轮循环执行</span></span>\n<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#676E95;">// 下面两行，本轮循环执行</span></span>\n<span class="line"><span style="color:#A6ACCD;">process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">nextTick</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">4</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><h3 id="process-nexttick" tabindex="-1">process.nextTick() <a class="header-anchor" href="#process-nexttick" aria-hidden="true">#</a></h3><p>process.nextTick 这个名字有点误导，它是在本轮循环执行的，而且是所有异步任务里面<strong>最快执行的</strong>。</p><p>Node 执行完所有同步任务，接下来就会执行 process.nextTick 的任务队列。所以，下面这行代码是第二个输出结果。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">nextTick</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>基本上，如果你希望异步任务尽可能快地执行，那就使用 process.nextTick。</p><h3 id="微任务" tabindex="-1">微任务 <a class="header-anchor" href="#微任务" aria-hidden="true">#</a></h3><p>根据语言规格，Promise 对象的回调函数，会进入异步任务里面的&quot;微任务&quot;（microtask）队列。</p><p>微任务队列追加在 process.nextTick 队列的后面，也属于本轮循环。所以，下面的代码总是先输出3，再输出4。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">nextTick</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">4</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#676E95;">// 3</span></span>\n<span class="line"><span style="color:#676E95;">// 4</span></span>\n<span class="line"></span></code></pre></div><p><img src="/fe-tutorial/assets/javascript-browser-EventLoop-node-eg1.be8de79e.png" alt="microtask"></p><p><strong>注意，只有前一个队列全部清空以后，才会执行下一个队列。</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">nextTick</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">nextTick</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">4</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#676E95;">// 1</span></span>\n<span class="line"><span style="color:#676E95;">// 3</span></span>\n<span class="line"><span style="color:#676E95;">// 2</span></span>\n<span class="line"><span style="color:#676E95;">// 4</span></span>\n<span class="line"></span></code></pre></div><p>上面代码中，全部 process.nextTick 的回调函数，执行都会早于 Promise 的。</p><p><strong>至此，循环的执行顺序就是：</strong></p><ol><li>同步任务</li><li>process.nextTick()</li><li>微任务</li></ol><h3 id="事件循环的概念" tabindex="-1">事件循环的概念 <a class="header-anchor" href="#事件循环的概念" aria-hidden="true">#</a></h3><p>为了理解次轮循环的执行顺序，这就必须理解什么是事件循环（event loop）了。</p><p>Node 的官方文档是这样介绍的：</p><blockquote><p>&quot;When Node.js starts, it initializes the event loop, processes the provided input script which may make async API calls, schedule timers, or call process.nextTick(), then begins processing the event loop.&quot;</p></blockquote><p>它表达了三层意思。</p><p>首先，有些人以为，除了主线程，还存在一个单独的事件循环线程。不是这样的，只有一个主线程，事件循环是在主线程上完成的。</p><p>其次，Node 开始执行脚本时，会先进行事件循环的初始化，但是这时事件循环还没有开始，会先完成下面的事情：</p><ul><li>同步任务</li><li>发出异步请求</li><li>规划定时器生效的时间</li><li>执行process.nextTick()等等</li></ul><h3 id="事件循环的六个阶段" tabindex="-1">事件循环的六个阶段 <a class="header-anchor" href="#事件循环的六个阶段" aria-hidden="true">#</a></h3><p>事件循环会无限次地执行，一轮又一轮。只有异步任务的回调函数队列清空了，才会停止执行。</p><p>每一轮的事件循环，<strong>分成六个阶段</strong>。这些阶段会依次执行：</p><ol><li>timers</li><li>I/O callbacks</li><li>idle, prepare</li><li>poll</li><li>check</li><li>close callbacks</li></ol><p><strong>每个阶段都有一个先进先出的回调函数队列。只有一个阶段的回调函数队列清空了，该执行的回调函数都执行了，事件循环才会进入下一个阶段。</strong></p><p><img src="/fe-tutorial/assets/javascript-browser-EventLoop-node-eg2.c3ff876c.png" alt="EventLoop"></p><p>下面简单介绍一下每个阶段的含义：</p><p><strong>1. timers</strong></p><p>这个是定时器阶段，处理 <code>setTimeout()</code> 和 <code>setInterval()</code> 的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。</p><p><strong>2. I/O callbacks</strong></p><p>除了以下操作的回调函数，其他的回调函数都在这个阶段执行。</p><ul><li><code>setTimeout()</code> 和 <code>setInterval()</code> 的回调函数；</li><li><code>setImmediate()</code> 的回调函数；</li><li>用于关闭请求的回调函数，比如 <code>socket.on(&#39;close&#39;, ...)</code>。</li></ul><p><strong>3. idle, prepare</strong></p><p>该阶段只供 libuv 内部调用，这里可以忽略。</p><p><strong>4. Poll</strong></p><p>这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。</p><p>这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。</p><p><strong>5. check</strong></p><p>该阶段执行 <code>setImmediate()</code> 的回调函数。</p><p><strong>6. close callbacks</strong></p><p>该阶段执行关闭请求的回调函数，比如 <code>socket.on(&#39;close&#39;, ...)</code>。</p><h3 id="settimeout-和-setimmediate" tabindex="-1">setTimeout 和 setImmediate <a class="header-anchor" href="#settimeout-和-setimmediate" aria-hidden="true">#</a></h3><p>由于 <code>setTimeout</code> 在 timers 阶段执行，而 <code>setImmediate</code> 在 check 阶段执行。所以，<code>setTimeout</code> 会早于 <code>setImmediate</code> 完成。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>上面代码应该先输出 1，再输出 2，但是实际执行的时候，结果却是不确定，有时还会先输出 2，再输出 1。</p><p>这是因为 <code>setTimeout</code> 的第二个参数默认为 0。但是实际上，Node 做不到0毫秒，最少也需要 1 毫秒，根据官方文档，第二个参数的取值范围在 1 毫秒到 2147483647 毫秒之间。也就是说，<code>setTimeout(f, 0)</code> 等同于 <code>setTimeout(f, 1)</code>。</p><p><strong>实际执行的时候，进入事件循环以后，有可能到了 1 毫秒，也可能还没到 1 毫秒，取决于系统当时的状况。如果没到 1 毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行 <code>setImmediate</code> 的回调函数。</strong></p><p>但是，下面的代码一定是先输出 2，再输出 1：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> fs </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">fs</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">fs</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">readFile</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">test.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">setImmediate</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">2</span><span style="color:#F07178;">))</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers <code>阶段。因此，setImmediate</code> 才会早于 <code>setTimeout</code> 执行。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-hidden="true">#</a></h2><ul><li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noreferrer">JavaScript 运行机制详解：再谈Event Loop</a></li><li><a href="https://zhuanlan.zhihu.com/p/33058983" target="_blank" rel="noreferrer">详解JavaScript中的Event Loop（事件循环）机制</a></li><li><a href="https://juejin.im/post/5aab2d896fb9a028b86dc2fd" target="_blank" rel="noreferrer">JavaScript 运行机制--Event Loop详解</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html" target="_blank" rel="noreferrer">Node 定时器详解</a></li></ul>',109);const A=s(r,[["render",function(s,p,e,t,c,r){const A=n("VueJobs");return a(),l("div",null,[i,o(A),y])}]]);export{c as __pageData,A as default};
