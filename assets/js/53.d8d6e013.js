(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{311:function(t,e,a){"use strict";a.r(e);var r=a(0),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序","aria-hidden":"true"}},[t._v("#")]),t._v(" 排序")]),t._v(" "),a("h2",{attrs:{id:"常用的排序算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用的排序算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 常用的排序算法")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("排序算法")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("时间复杂度")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("是否基于比较")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("冒泡、插入、选择")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("O(n^2)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("快排、归并")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("o(nlogn)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("桶、计数、基数")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("O(n)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("否")])])])]),t._v(" "),a("h2",{attrs:{id:"如何分析一个算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何分析一个算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 如何分析一个算法")]),t._v(" "),a("p",[t._v("学习排序算法，除了要知道它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。分析一个排序算法应该要考虑以下几个方面")]),t._v(" "),a("h3",{attrs:{id:"排序算法的执行效率"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序算法的执行效率","aria-hidden":"true"}},[t._v("#")]),t._v(" 排序算法的执行效率")]),t._v(" "),a("p",[t._v("对于排序算法，需要从以下几点来衡量")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("最好情况、最坏情况、平均时间复杂度")]),t._v("：这样可以方便知道排序算法在不同数据下的性能表现。")]),t._v(" "),a("li",[a("strong",[t._v("时间复杂度的系数、常数、低阶")]),t._v("：时间复杂度反应的是执行时间随着数据规模增长的变化趋势，但是实际的开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，对于同一阶时间复杂度的排序算法的性能对比，就需要把系数、常数、低阶考虑进来。")]),t._v(" "),a("li",[a("strong",[t._v("比较次数和交换（或移动）次数")]),t._v("：对于基于比较的排序算法，会涉及两种操作，一种是元素比较大小，另一种是交换（或移动），所以分析执行效率的时候，应该把比较次数和交换（或移动次数）也考虑进来。")])]),t._v(" "),a("h3",{attrs:{id:"排序算法的内存消耗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序算法的内存消耗","aria-hidden":"true"}},[t._v("#")]),t._v(" 排序算法的内存消耗")]),t._v(" "),a("p",[t._v("内存消耗可以通过空间复杂度来衡量。这里还引入一个概念，"),a("strong",[t._v("原地排序")]),t._v("。原地排序算法，特指空间复杂度为 O(1) 的排序算法。冒泡、插入、选择都属于原地排序。")]),t._v(" "),a("h3",{attrs:{id:"排序算法的稳定性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序算法的稳定性","aria-hidden":"true"}},[t._v("#")]),t._v(" 排序算法的稳定性")]),t._v(" "),a("p",[t._v("针对排序算法还有一个重要的度量指标，"),a("strong",[t._v("稳定性")]),t._v("。就是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序顺序不变。")]),t._v(" "),a("p",[t._v("例如，一组数据 2，3，4，2，按照大小排序之后就是 2，2，3，4。")]),t._v(" "),a("p",[t._v("这里边有两个 2，经过某种排序算法排序之后，如果两个 2 的前后顺序没有变化，那么就把这种算法叫作"),a("strong",[t._v("稳定的排序算法")]),t._v("；如果前后顺序发生变化，那对应的排序算法就叫作"),a("strong",[t._v("不稳定的排序算法")]),t._v("。")])])}),[],!1,null,null,null);e.default=v.exports}}]);