(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{144:function(t,a,e){t.exports=e.p+"assets/img/dataStructure-linked-singleLinkedList.2864c31b.png"},145:function(t,a,e){t.exports=e.p+"assets/img/dataStructure-linked-insertAndDelete.7d2d7b95.jpg"},146:function(t,a,e){t.exports=e.p+"assets/img/dataStructure-linked-circularLinkedList.e4b5f858.png"},147:function(t,a,e){t.exports=e.p+"assets/img/dataStructure-linked-doubleLinkedList.5acef0bf.png"},148:function(t,a,e){t.exports=e.p+"assets/img/dataStructure-linked-doubleCircularLinkedList.bee5d08d.jpg"},187:function(t,a,e){"use strict";e.r(a);var r=e(0),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链表","aria-hidden":"true"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),r("h2",{attrs:{id:"概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概念","aria-hidden":"true"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),r("p",[t._v("数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 200 MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便剩余的可用空间大于 200 MB，仍然会申请失败。")]),t._v(" "),r("blockquote",[r("p",[t._v("链表，不需要一块连续的内存空间，它通过“指针”将一组"),r("strong",[t._v("零散的内存块")]),t._v("串联起来使用。")])]),t._v(" "),r("p",[t._v("常见的链表结构有三种，分别是：单链表、双链表和循环链表。")]),t._v(" "),r("h2",{attrs:{id:"单链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单链表","aria-hidden":"true"}},[t._v("#")]),t._v(" 单链表")]),t._v(" "),r("p",[t._v("链表通过指针将一组零散的内存块串联在一起。其中，把内存块称为"),r("strong",[t._v("结点")]),t._v("。每个结点除了包含数据之外，还要记录链的下一结点地址。把记录下个结点地址的指针叫作"),r("strong",[t._v("后继指针 next")]),t._v("。")]),t._v(" "),r("p",[t._v("其中两个结点比较特殊")]),t._v(" "),r("ul",[r("li",[t._v("头结点：第一个结点，用来记录链表的基地址，有了它，就可以遍历整条链表")]),t._v(" "),r("li",[t._v("尾结点：最后一个结点，它的指针不指向下一个节点，而是指向空地址"),r("strong",[t._v("NULL")])])]),t._v(" "),r("p",[r("img",{attrs:{src:e(144),alt:"singleLinkedList"}})]),t._v(" "),r("p",[t._v("与数组一样，聊表也支持查找、插入和删除。")]),t._v(" "),r("p",[t._v("数组进行插入和删除时，为了保持连续，需要搬移元素，所以时间复杂度是 O(n)。而链表存储空间本身就是不连续的，所以它插入和删除是很快速的，时间复杂度为 o(1)。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(145),alt:"linkedInsertAndDelete"}})]),t._v(" "),r("p",[t._v("但是，链表想要随机访问第 k 个元素的时候，就没有数组那么高效了。因为它是非连续存储的，所以无法像数组一样直接通过寻址公式计算出对应的内存地址。它需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。")]),t._v(" "),r("p",[t._v("所以它的访问性没有数组的好，需要 o(n) 的时间复杂度。")]),t._v(" "),r("h2",{attrs:{id:"循环聊表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#循环聊表","aria-hidden":"true"}},[t._v("#")]),t._v(" 循环聊表")]),t._v(" "),r("p",[t._v("循环链表和单链表唯一的区别在尾结点，它的尾结点并不是指向 NULL，而是指向头指针。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(146),alt:"circularLinkedList"}})]),t._v(" "),r("p",[t._v("和单链表相比，"),r("strong",[t._v("优点")]),t._v("是从链尾到链头比较方便，特别适合处理环形结构的数据。")]),t._v(" "),r("h2",{attrs:{id:"双链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双链表","aria-hidden":"true"}},[t._v("#")]),t._v(" 双链表")]),t._v(" "),r("p",[t._v("双链表顾名思义，它支持两个方向，每个结点不止有一个后继指针——next，指向后面的结点；还有一个前驱指针——prev，指向前面的结点。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(147),alt:"doubleLinkedList"}})]),t._v(" "),r("p",[t._v("和单链表相比，它需要更多的内存空间，因为它需要额外的两个空间来存储前驱指针和后继指针。但是它可以双向遍历，有更好的灵活性，那它适合解决什么问题呢？")]),t._v(" "),r("p",[t._v("前面，单链表的插入和删除的时间复杂都是 O(1)，双向链表还能更加高效吗？实际上这种说法不准确的，再看一下链表的插入和删除。")]),t._v(" "),r("p",[t._v("先看删除，实际中开发中，从链表中删除一个数据无外乎这两种情况：")]),t._v(" "),r("ol",[r("li",[t._v("删除结点中“值等于某个给定值”的结点")]),t._v(" "),r("li",[t._v("删除给定指针指向的结点")])]),t._v(" "),r("p",[t._v("对于第一种情况，无论是单链表还是双链表都需要从头结点开始，一个一个依次遍历找到值等于给定值的结点，然后通过前面的删除操作将其删除。")]),t._v(" "),r("p",[t._v("虽然，"),r("strong",[t._v("单纯的删除操作时间复杂度是 O(1)，但是遍历查找的时间复杂度 O(n)")]),t._v("，根据复杂度分析的加法原则，删除值等于给定值的结点的总时间复杂度为 "),r("strong",[t._v("O(n)")]),t._v("。")]),t._v(" "),r("p",[t._v("对于第二种情况，已经知道要删除的结点，但是要删除某个节点 q 需要知道其前驱结点，而单链表不支持直接获取前驱结点。为了找到前驱结点，需要从头节点开始遍历，知道 "),r("code",[t._v("p->next=q")]),t._v("，说明 p 是 q 的前驱结点。")]),t._v(" "),r("p",[t._v("对应双向链表，这种情况就比较方便了，它本身已经保存了前驱指针，指向前驱结点。所以对于第二种情况，单链表的时间复杂度为 O(n)，而双向链表的时间复杂度为 O(1)。")]),t._v(" "),r("p",[t._v("同理，插入节点也是一样的。")]),t._v(" "),r("h2",{attrs:{id:"双向循环链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双向循环链表","aria-hidden":"true"}},[t._v("#")]),t._v(" 双向循环链表")]),t._v(" "),r("p",[t._v("把循环链表和循环链表整合到一起就得到双向循环链表了。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(148),alt:"doubleCircularLinkedList"}})]),t._v(" "),r("h2",{attrs:{id:"和数组比较"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#和数组比较","aria-hidden":"true"}},[t._v("#")]),t._v(" 和数组比较")]),t._v(" "),r("p",[t._v("除了时间复杂度上的差别，还有一个非常重要区别是占用的内存空间。")]),t._v(" "),r("p",[t._v("数组一经声明，就占用整块连续的空间，如果声明的数组过大，系统可能没有足够的空间分配给它，导致“内存不足”；如果声明的数组过小，则不够用时，就会申请一块更大的空间，然后把原来的数据拷贝过去，非常费时。而链表本身没有大小的限制，天然支持动态扩容。")]),t._v(" "),r("h2",{attrs:{id:"手写链表技巧"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#手写链表技巧","aria-hidden":"true"}},[t._v("#")]),t._v(" 手写链表技巧")]),t._v(" "),r("h3",{attrs:{id:"注意指针丢失"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#注意指针丢失","aria-hidden":"true"}},[t._v("#")]),t._v(" 注意指针丢失")]),t._v(" "),r("p",[t._v("比如，想在相邻的 a 和 b 节点之间插入 x，假设当前指针 p 指向结点 a。那么一不小心，就会写成下面的样子。第一步之后，p->next 已经不再指向 b 节点，而是指向 x。第 2 行代码相当于将 x 赋值给 x->next，自己指向自己。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("p->next = x;\nx->next = p->next\n")])])]),r("p",[t._v("所以，在代码之前，可以通过画图法或者举例法辅助理解。")]),t._v(" "),r("h3",{attrs:{id:"注意边界条件的处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#注意边界条件的处理","aria-hidden":"true"}},[t._v("#")]),t._v(" 注意边界条件的处理")]),t._v(" "),r("p",[t._v("要实现一个没有 bug 的链表代码，写完代码之后一定要考虑检查边界条件是否全面，常用的检查代码是否正确的边间条件有以下几个。检查自己的代码在一下条件能否正常工作。")]),t._v(" "),r("ul",[r("li",[t._v("链表为空")]),t._v(" "),r("li",[t._v("链表只包含一个结点")]),t._v(" "),r("li",[t._v("链表只包含两个结点")]),t._v(" "),r("li",[t._v("代码逻辑在处理头结点和尾结点时会怎样")]),t._v(" "),r("li",[t._v("其他自己场景相关的边界条件...")])])])}),[],!1,null,null,null);a.default=v.exports}}]);