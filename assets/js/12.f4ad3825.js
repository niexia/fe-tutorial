(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{175:function(t,a,s){t.exports=s.p+"assets/img/dataStructure-HashTable-insert.36cc3e80.png"},176:function(t,a,s){t.exports=s.p+"assets/img/dataStructure-HashTable-find.1c160136.png"},177:function(t,a,s){t.exports=s.p+"assets/img/dataStructure-HashTable-notFound.2e7ed55b.png"},178:function(t,a,s){t.exports=s.p+"assets/img/dataStructure-HashTable-delete.840a8a2c.png"},179:function(t,a,s){t.exports=s.p+"assets/img/dataStructure-HashTable-linked.9a4a80f3.png"},318:function(t,a,s){"use strict";s.r(a);var e=s(0),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"散列表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#散列表","aria-hidden":"true"}},[t._v("#")]),t._v(" 散列表")]),t._v(" "),e("p",[t._v("散列表英文叫作 Hash Table，平时也叫“哈希表”或者“Hash 表”。")]),t._v(" "),e("h2",{attrs:{id:"散列思想"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#散列思想","aria-hidden":"true"}},[t._v("#")]),t._v(" 散列思想")]),t._v(" "),e("p",[e("strong",[t._v("散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说没有数组就没有散列表。")])]),t._v(" "),e("p",[t._v("看一个例子，现在有 89 名选手参加比赛，为了方便记录成绩，每个选手都有自己的编号。这 89 名选手的编号依次是 1~89。现在我们需要编程实现一个功能，通过编号找到对应的选手信息，怎么做？")]),t._v(" "),e("p",[t._v("那就可以把这 89 名选手的信息放到数组了，用编号对应下标，数组下标 1 放的是编号为 1 的选手信息，以此类推。这样通过编号获取选手 x 的信息的时候，只需要将下标为 x 的数组元素元素取出来就好，时间复杂度为 O(1)。")]),t._v(" "),e("p",[t._v("要是在编号上再加入其他信息，例如年级、班级这些信息，例如，010822：前两位 01 表示年级，中间两位 08 表示班级，后两位还是原来的表示编号 1~89，怎么实现刚才的功能？")]),t._v(" "),e("p",[t._v("还是一样通过数组来存储选手信息，这个时候不能直接用编号来当作下标了，但是可以"),e("strong",[t._v("截取后两位")]),t._v("来作为下标存储对应的选手信息，那么处理和前面是一样的。")]),t._v(" "),e("p",[t._v("这就是典型的散列思想：")]),t._v(" "),e("ol",[e("li",[t._v("参赛选手的编号叫作"),e("strong",[t._v("键（key）")]),t._v("（或关键字），用来标识一个选手；")]),t._v(" "),e("li",[t._v("把参赛编号转为数组下标的映射方法叫作"),e("strong",[t._v("散列函数")]),t._v("（或“Hash 函数”，“哈希函数”）；")]),t._v(" "),e("li",[t._v("散列函数计算得到的值叫作"),e("strong",[t._v("散列值")]),t._v("（或“Hash 值”，“哈希值”）。")])]),t._v(" "),e("p",[e("strong",[t._v("所以，散列表就是用数组支持下标随机访问时间复杂度为 O(1) 的特性。通过散列函数把键映射为下标，然后将数据存储到数组中对应下标的位置。当我们通过键来查询数据时，用同样的散列函数，将键转换为数组下标，从对应的下标位置获取元素。")])]),t._v(" "),e("h2",{attrs:{id:"散列函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#散列函数","aria-hidden":"true"}},[t._v("#")]),t._v(" 散列函数")]),t._v(" "),e("p",[t._v("通过上面的例子，散列函数顾名思义就是一个函数，把它定义为 "),e("strong",[t._v("hash(key)")]),t._v("：")]),t._v(" "),e("ol",[e("li",[t._v("key：就是元素的键值")]),t._v(" "),e("li",[t._v("hash(key)：就是散列函数执行计算之后得到的散列值")])]),t._v(" "),e("p",[t._v("上面的例子，散列函数可以表示为：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("hash")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("key")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" lastTwoChars "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" hashValue "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("parseInt")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lastTwoChars"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" hashValue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("这个散列函数还是比较简单的，刚刚的例子中，已经知道每个编号的定义和规律，所以散列函数只需要截取后面两位的编号作为散列值。但是如果参数选手的编号是随机生成的 6 为数字，或者用的是 a 到 z 的字符串呢？那这个散列函数就不行了。")]),t._v(" "),e("h3",{attrs:{id:"散列函数设计的基本要求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#散列函数设计的基本要求","aria-hidden":"true"}},[t._v("#")]),t._v(" 散列函数设计的基本要求")]),t._v(" "),e("p",[t._v("散列函数设计的基本要求有 3 个：")]),t._v(" "),e("ol",[e("li",[t._v("散列函数计算得到的散列值是一个非负整数；")]),t._v(" "),e("li",[t._v("如果 key1 == key2，那么 hash(key1) == hash(key2)；")]),t._v(" "),e("li",[t._v("如果 key1 != key1，那么 hash(key1) != hash(key2)。")])]),t._v(" "),e("p",[t._v("第一点比较好理解，因为散列表是借助数组来实现的，而数组的下标是从 0 开始的，所以散列值也要是一个非负整数。")]),t._v(" "),e("p",[t._v("第二点也比较好理解，相同的 key，经过散列函数之后得到的散列值应该也是相同的。不然通过 key 存数据之后，再通过 key 来获取数据时就那不多对应的数据了。")]),t._v(" "),e("p",[t._v("第三点看起来合情合理，但是"),e("strong",[t._v("想找到一个不同的 key 对应的散列值不一样的散列函数，几乎不可能")]),t._v("。即使是著名的 MD5、SHA、CRC 等哈希算法，也无法避免"),e("strong",[t._v("散列冲突")]),t._v("。而且因为数组的存储空间有限，而散列值必须在这个范围内，这也加大了散列冲突的概率。")]),t._v(" "),e("p",[t._v("所以几乎无法找到一个完美的散列函数，即使找到，也需要很大的成本，所以"),e("strong",[t._v("针对散列冲突，需要通过其他途径解决")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"解决散列冲突"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决散列冲突","aria-hidden":"true"}},[t._v("#")]),t._v(" 解决散列冲突")]),t._v(" "),e("p",[t._v("常用的解决散列冲突方法有 2 类：开放寻址法（open addressing）和链表法 （chaining）。")]),t._v(" "),e("h3",{attrs:{id:"开放寻址法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开放寻址法","aria-hidden":"true"}},[t._v("#")]),t._v(" 开放寻址法")]),t._v(" "),e("p",[t._v("开放寻址法的核心思想就是：如果出现了散列冲突，就重新探测一个空闲位置，将其插入。先看一下比较简单探测方法——线性探测。")]),t._v(" "),e("ul",[e("li",[t._v("线性探测")])]),t._v(" "),e("ol",[e("li",[t._v("插入数据")])]),t._v(" "),e("p",[t._v("往散列表插入数据，如果这个键经过散列函数散列之后，得到的散列值对应的存储位置已经被占用了，"),e("strong",[t._v("那么就从当前位置，依次往后找，看是否有空闲位置，直到找到为止")]),t._v("。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(175),alt:"HashTable-insert"}})]),t._v(" "),e("p",[t._v("X 经过散列函数计算后，应该要放到下标为 6 的位置，但是这个位置已经有数据了，所以从当前位置依次遍历，看是否有位置，到尾部依然没有，则再从表头开始找，直到找到空位 2，将其插入。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("查询数据")])]),t._v(" "),e("p",[t._v("查询数据的过程类似于插入数据，根据散列计算得到的散列值，获取数组下标为散列值的元素，把它和要查找的元素相比。如果相等，则说明是要查找的元素；不想等则一次往后查找。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(176),alt:"HashTable-insert"}})]),t._v(" "),e("p",[t._v("如果遍历到数组的空闲位置，还没有找到，则说明要查找的元素并没有在散列表中。"),e("strong",[t._v("这是因为插入数据遇到散列冲突时，是通过依次往后遍历查找空闲的位置的，所以遍历查找的时候，如果有空位，则说明根本就没有插入这个数据，即不存在")]),t._v("。")]),t._v(" "),e("nx-tip",{attrs:{text:"查询的时候根据散列计算得到的散列值，获取数组下标为散列值的元素，把它和要查找的元素相比。这里查找的时候是通过 key，是不是存储的时候把 key 也存储了？不然怎么判断是不是要查找的元素？"}},[e("p",[e("img",{attrs:{src:s(177),alt:"HashTable-insert"}})]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("删除数据")])]),t._v(" "),e("p",[t._v("删除数据有点特别。不能单纯的将要删除的元素设置为空，不然就会出现查询的时候差不多数据的情况。")]),t._v(" "),e("p",[t._v("可以将删除的元素标识为 deleted，这样查询的时候遇到 deleted 时不要停下来，继续往下探测。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(178),alt:"HashTable-insert"}})]),t._v(" "),e("p",[e("strong",[t._v("线性探测存在的问题：")])]),t._v(" "),e("p",[t._v("当散列表的数据越来越多时，散列冲突的概率就越来越大。而随着空闲位置越来越少，那么探测时间就会越来越长，可能需要探测整个散列表，所以"),e("strong",[t._v("最坏时间复杂度为 O(n)。")])]),t._v(" "),e("ul",[e("li",[t._v("二次探测")])]),t._v(" "),e("p",[t._v("二次探测类似于线性探测，区别是，线性探测的"),e("strong",[t._v("步长是 1")]),t._v("，二次探测的"),e("strong",[t._v("步长是“二次方”")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 线性探测\nhash(key) -> hash(key)+1 -> hash(key)+2 -> ...\n\n// 二次探测\nhash(key) -> hash(key)+1^2 -> hash(key)+2^2 -> ...\n")])])]),e("ul",[e("li",[t._v("双重散列")])]),t._v(" "),e("p",[t._v("所谓双重散列，就是不仅要使用一个散列表，而是通过一组散列函数 hash1(key)、hash2(key)、hash3(key) ...。先用第一个散列函数，如果计算出来的位置被占用了，就用第二个，直到找到空闲位置。")]),t._v(" "),e("p",[e("strong",[t._v("以上这些方法，都是当散列冲突时，通过查找另一个空闲位置来解决")]),t._v("。但是，不过哪种探测方法，当散列表中的空闲位置不多时，散列冲突的概率都会大大提高。"),e("strong",[t._v("为了保证散列表的操作效率，就需要保证散列表中有一定空闲的槽位")]),t._v("。")]),t._v(" "),e("p",[t._v("用散列表的"),e("strong",[t._v("装载因子")]),t._v("表示空闲槽位的比例：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("装载因子 = 填入表中的元素个数 / 散列表的长度\n")])])]),e("p",[t._v("也就是，装载因子越大，空闲位置越少，冲突概率越大；反之，装载因子越小，空闲位置越多，冲突概率越小。")]),t._v(" "),e("h3",{attrs:{id:"链表法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链表法","aria-hidden":"true"}},[t._v("#")]),t._v(" 链表法")]),t._v(" "),e("p",[t._v("链表法是一种"),e("strong",[t._v("更加常用")]),t._v("的散列冲突解决方法。相比开发寻址法，它也更加简单。如图所示，"),e("strong",[t._v("散列表中每个槽（slot）或者桶（bucket）都会对应一条链表，散列值相同的元素都放到相同槽位对应的链表中")]),t._v("。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(179),alt:"HashTable-linked"}})]),t._v(" "),e("p",[t._v("插入数据的时候，通过散列函数计算得到的散列值对应到散列槽位，将数据插入到槽位中链表即可，时间复杂度为 O(1)。")]),t._v(" "),e("p",[t._v("查询和删除的时候，也需要根据散列值对应到散列槽位，然后遍历链表进行查找或删除。时间复杂度为 O(k)，k 为链表的长度。")]),t._v(" "),e("p",[t._v("对于比较均匀的散列表来说，每条链表的长度 k = n/m，n 为散列中数据的个数，m 为散列中槽位的个数。")]),t._v(" "),e("p",[e("strong",[t._v("散列表的两个核心问题就是“散列函数设计”和“散列冲突解决”")]),t._v("。散列函数设计不好，或者装载因子过高，都可能导致散列冲突，导致查询效率下降。")])])],1)}),[],!1,null,null,null);a.default=v.exports}}]);