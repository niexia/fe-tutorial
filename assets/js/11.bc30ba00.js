(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{159:function(t,a,s){t.exports=s.p+"assets/img/dataStructure-tree.da939a19.png"},160:function(t,a,s){t.exports=s.p+"assets/img/dataStructure-tree-example.5b3c3344.png"},161:function(t,a,s){t.exports=s.p+"assets/img/dataStructure-tree-binaryTree.aa38250e.png"},162:function(t,a,s){t.exports=s.p+"assets/img/dataStructure-tree-binaryTree-linkedStore.7da99306.png"},163:function(t,a,s){t.exports=s.p+"assets/img/dataStructure-tree-binaryTree-arrayStore.bf3c63e3.png"},307:function(t,a,s){"use strict";s.r(a);var n=s(0),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树","aria-hidden":"true"}},[t._v("#")]),t._v(" 二叉树")]),t._v(" "),n("p",[t._v("二叉树是一种非线性表结构，二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？")]),t._v(" "),n("h2",{attrs:{id:"树（tree）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#树（tree）","aria-hidden":"true"}},[t._v("#")]),t._v(" 树（Tree）")]),t._v(" "),n("p",[t._v("这里的树和生活中的“树”很像，先看看几棵树：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(159),alt:"tree"}})]),t._v(" "),n("p",[t._v("树的常用概念有：")]),t._v(" "),n("ol",[n("li",[t._v("节点：树中的每个元素称为节点；")]),t._v(" "),n("li",[t._v("父子关系：相连的相邻节点之间的关系叫作父子关系；")]),t._v(" "),n("li",[t._v("父节点：A 节点就是 B 节点的父节点；")]),t._v(" "),n("li",[t._v("子节点：B 节点就是 A 节点的子节点；")]),t._v(" "),n("li",[t._v("根节点：没有父节点的节点，也就是图中的 A；")]),t._v(" "),n("li",[t._v("叶子节点（或者叶节点）：没有子节点的节点，也就是图中的 G、H、I、J、K；")]),t._v(" "),n("li",[t._v("节点的高度："),n("strong",[t._v("节点到叶子节点")]),t._v("的最长路径（边数）；")]),t._v(" "),n("li",[t._v("节点的深度："),n("strong",[t._v("根节点到这个节点")]),t._v("经历的边的个数；")]),t._v(" "),n("li",[t._v("节点的层数：节点的深度 "),n("strong",[t._v("+ 1")]),t._v("；")]),t._v(" "),n("li",[t._v("树的高度：根节点的高度。")])]),t._v(" "),n("p",[n("img",{attrs:{src:s(160),alt:"tree-example"}})]),t._v(" "),n("p",[t._v("高度就类似楼层一样，从下往上，起点记为 0；而深度类似水的深度，从上往下，起点也记为 0；层数跟深度类似，不过起点记为 1。")]),t._v(" "),n("h2",{attrs:{id:"二叉树-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树-2","aria-hidden":"true"}},[t._v("#")]),t._v(" 二叉树")]),t._v(" "),n("p",[t._v("树的结构中常用的还是二叉树。")]),t._v(" "),n("ol",[n("li",[t._v("二叉树")])]),t._v(" "),n("p",[t._v("二叉树的每个节点"),n("strong",[t._v("最多")]),t._v("有两个子节点，分别是左子节点和右子节点。注意这里是最多也就是并不要求都有两个子节点。")]),t._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[t._v("满二叉树")])]),t._v(" "),n("p",[t._v("二叉树中，叶子节点都在底层，并且除了叶子节点之外，每个节点"),n("strong",[t._v("都有")]),t._v("左右两个子节点，这种二叉树就叫作满二叉树。")]),t._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[t._v("完全二叉树")])]),t._v(" "),n("p",[t._v("二叉树中，叶子节点都在"),n("strong",[t._v("最底下两层")]),t._v("，最后一层的叶子节点都"),n("strong",[t._v("靠左排列")]),t._v("，并且除了最后一层，其他层的节点个数都要"),n("strong",[t._v("达到最大")]),t._v("，这种二叉树叫作完全二叉树。")]),t._v(" "),n("p",[n("img",{attrs:{src:s(161),alt:"binaryTree"}})]),t._v(" "),n("nx-tip",{attrs:{text:"完全二叉树的特征并不是很明显，为什么要特意说明呢？为什么要求它最后一层的叶子节点靠左排列？它的定义目的在哪？"}}),t._v(" "),n("p",[t._v("要理解完全二叉树的定义的由来，从二叉树的存储说起。")]),t._v(" "),n("h2",{attrs:{id:"二叉树的存储"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的存储","aria-hidden":"true"}},[t._v("#")]),t._v(" 二叉树的存储")]),t._v(" "),n("p",[t._v("存储二叉树有两种方法：链式存储法和顺序存储法。")]),t._v(" "),n("ol",[n("li",[t._v("链式存储法")])]),t._v(" "),n("p",[t._v("每个节点有 3 个字段，其中一个存储数据，另外是两个指向左右子节点的指针。只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储结构比较常用，大部分二叉树都是通过这种结构来实现。")]),t._v(" "),n("p",[n("img",{attrs:{src:s(162),alt:"linkedStore"}})]),t._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[t._v("顺序存储法")])]),t._v(" "),n("p",[t._v("用数组来存储，如果节点 X 存储在下标为 "),n("code",[t._v("i")]),t._v(" 的位置，那它的左子节点存储在 "),n("code",[t._v("2 * i")]),t._v(" 的位置，右子节点存储在 "),n("code",[t._v("2 * i + 1")]),t._v(" 的位置。反过来，下标 "),n("code",[t._v("i/2")]),t._v(" 位置存储的就是它的父节点。通过这种方式，只要知道根节点的存储位置（一般情况，为了方便计算，"),n("strong",[t._v("根节点会存储在下标为 1 的位置")]),t._v("），就可以通过下标的计算，把整棵树都串起来。")]),t._v(" "),n("p",[n("img",{attrs:{src:s(163),alt:"arrayStore"}})]),t._v(" "),n("p",[t._v("这个时候，如果是完全二叉树，它仅仅浪费一个下标为 0 的存储位置，而非完全二叉树，其实就会浪费比较多的数组存储空间。")]),t._v(" "),n("p",[n("strong",[t._v("所以，如果一棵二叉树是完全二叉树，那么使用数组存储是最节省内存的一种方式。")])]),t._v(" "),n("h2",{attrs:{id:"二叉树的遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的遍历","aria-hidden":"true"}},[t._v("#")]),t._v(" 二叉树的遍历")]),t._v(" "),n("p",[t._v("如何将所有节点都遍历打印出来？经典的方法有 3 种："),n("strong",[t._v("前序遍历")]),t._v("、"),n("strong",[t._v("中序遍历")]),t._v("和"),n("strong",[t._v("后序遍历")]),t._v("。")]),t._v(" "),n("ol",[n("li",[t._v("前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。")]),t._v(" "),n("li",[t._v("中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。")]),t._v(" "),n("li",[t._v("后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。")])]),t._v(" "),n("p",[t._v("二叉树的前、中、后序遍历就是一个递归的过程。为了写递归代码，需要先写出递推公式。而写递推公式，关键就是把要解决的问题 a，分解成子问题 b 和 c，再看如何利用 b，c 来解决 A。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 前序遍历的递推公式\npreOrder(r) = print r -> preOrder(r->left) -> preOrder(r->right)\n\n// 中序遍历的递推公式\npreOrder(r) = preOrder(r->left) -> print r -> preOrder(r->right)\n\n// 后序遍历的递推公式\npreOrder(r) = preOrder(r->left) -> preOrder(r->right) -> print r \n")])])]),n("p",[t._v("根据递推公式，用代码实现为：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("preOrder")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("node")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("preOrder")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("preOrder")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("inOrder")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("node")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("inOrder")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("inOrder")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("postOrder")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("node")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("postOrder")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("postOrder")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h3",{attrs:{id:"时间复杂度分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度分析","aria-hidden":"true"}},[t._v("#")]),t._v(" 时间复杂度分析")]),t._v(" "),n("p",[t._v("从前、中、后序遍历的顺序图中，每个节点最多被访问两次，所以遍历操作的时间复杂度跟节点的个数 n 成正比，也就是说时间复杂度为 O(n)。")]),t._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),n("p",[t._v("最常用的树就是二叉树，二叉树的每个节点最多只有两个子节点，分别是左子节点和右子节点。二叉树中，有两种树比较特殊，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。")]),t._v(" "),n("p",[t._v("回答开头的问题，二叉树有两种存储方法：用链表存储和用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组会比较浪费存储空间。")]),t._v(" "),n("p",[t._v("前、中、后序遍历都属于按深度遍历，另外还有一种按层遍历的方式。")])],1)}),[],!1,null,null,null);a.default=r.exports}}]);