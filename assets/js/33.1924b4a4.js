(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{311:function(a,t,v){a.exports=v.p+"assets/img/dataStructure-HashTable-dynamicCapacity.1263e28d.png"},445:function(a,t,v){"use strict";v.r(t);var _=v(38),r=Object(_.a)({},function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"设计散列表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计散列表","aria-hidden":"true"}},[a._v("#")]),a._v(" 设计散列表")]),a._v(" "),_("p",[a._v("散列表的两个核心问题就是“散列函数设计”和“散列冲突解决”。散列函数设计不好，或者装载因子过高，都可能导致散列冲突，导致查询效率下降。")]),a._v(" "),_("p",[a._v("在极端情况下，恶意的攻击者通过构造数据，是的所有数据经过散列函数之后都散列到同一个槽里，如果是基于链表实现的散列表，那么时间复杂度就退化为 O(n) 了。")]),a._v(" "),_("p",[a._v("比如散列表有 10 万个数据，退化的散列表查询的效率退化 10 万倍。如果之前 100 次查询需要 0.1 秒，那么现在需要 10000 秒。这样的查询可能消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。"),_("strong",[a._v("这也就是散列表碰撞攻击的基本原理")]),a._v("。")]),a._v(" "),_("h2",{attrs:{id:"如何设计散列函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何设计散列函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 如何设计散列函数")]),a._v(" "),_("p",[a._v("散列函数的设计直接影响散列表的性能。")]),a._v(" "),_("h3",{attrs:{id:"散列表的设计原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#散列表的设计原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 散列表的设计原则")]),a._v(" "),_("p",[a._v("首先，"),_("strong",[a._v("散列函数不能设计得太复杂")]),a._v("。过于复杂的散列函数，本身的计算就消耗很多时间，直接影响散列表的性能。")]),a._v(" "),_("p",[a._v("此次，"),_("strong",[a._v("散列函数生成散列值要尽可能的随机并且均匀分布")]),a._v("。这样才能避免或最小化散列冲突，即便出现冲突，散列到每个槽里的数据也比较平均，不会出现某个槽数据很多的情况。")]),a._v(" "),_("p",[a._v("实际工作中，还需要综合考虑各种因素，包括键的长度、特点、分布，还需要考虑散列表的大小。")]),a._v(" "),_("p",[a._v("例如，前面的参数选手例子，通过分析选手编号，把编号的后两位作为散列值。这种方法叫作"),_("strong",[a._v("数据分析法")]),a._v("。另外还有直接寻址法、平方取中法、折叠法、随机数法等等。")]),a._v(" "),_("h2",{attrs:{id:"装载因子过多怎么办"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#装载因子过多怎么办","aria-hidden":"true"}},[a._v("#")]),a._v(" 装载因子过多怎么办")]),a._v(" "),_("p",[a._v("用散列表的"),_("strong",[a._v("装载因子")]),a._v("表示空闲槽位的比例：")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v("装载因子 = 填入表中的元素个数 / 散列表的长度\n")])])]),_("p",[a._v("也就是，装载因子越大，空闲位置越少，冲突概率越大；反之，装载因子越小，空闲位置越多，冲突概率越小。")]),a._v(" "),_("p",[a._v("对于静态的数据集合，很容易根据数据特点设计出完美的、极少冲突的散列函数。但是对于动态的散列表来说，数据集合频繁变动，无法预估将要加入的数据个数，所以无法事先申请一个足够大的散列表。")]),a._v(" "),_("p",[a._v("随着数字加入，装载因子也就会加大。当装载因子大到一定程度，散列冲突会变得不可接受。")]),a._v(" "),_("h3",{attrs:{id:"动态扩容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#动态扩容","aria-hidden":"true"}},[a._v("#")]),a._v(" 动态扩容")]),a._v(" "),_("p",[a._v("还记得数组的"),_("strong",[a._v("动态扩容")]),a._v("吗？一样的，这里就需要对散列表进行动态扩容。如果当前装载因子是 0.8，当申请一个 2 倍的空间之后，通过扩容，装载因子就下降到 0.4 了。")]),a._v(" "),_("p",[a._v("和数组的动态扩容时数据搬移不同，散列表的数据搬移比较麻烦。"),_("strong",[a._v("因为散列表大小变了，数据的存储位置也变了，所以需要通过散列函数重新计算每个数据的位置")]),a._v("。")]),a._v(" "),_("p",[_("img",{attrs:{src:v(311),alt:"HashTable-dynamicCapacity"}})]),a._v(" "),_("p",[a._v("插入数据的时候，时间复杂度可以使用摊还分析法，时间复杂度接近最好时间复杂度，就是 O(1)。")]),a._v(" "),_("p",[a._v("装载因子超过某个阈值时，需要进行扩容。同样，如果装载因子小于某个值之后，如果对空间消耗非常敏感，那么这时就可以进行缩容。")]),a._v(" "),_("h3",{attrs:{id:"避免低效扩容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#避免低效扩容","aria-hidden":"true"}},[a._v("#")]),a._v(" 避免低效扩容")]),a._v(" "),_("p",[a._v("动态扩容的散列表插入一个数据很快。但当装载因子已经达到阈值，需要进行扩容，再插入数据，这时候就很慢。如果这部分的业务代码直接服务于客户，那这极个别的插入很慢的情况，体验也不好。")]),a._v(" "),_("p",[a._v("为了避免一次性扩容存在的问题，"),_("strong",[a._v("可以将扩容操作分散到插入操作中，分批完成。当装载因子达到阈值之后，只申请空间，单并不把老的数据搬移到新的散列表中")]),a._v("。")]),a._v(" "),_("p",[a._v("接着当有新数据插入的时候，先将新数据插入到新的散列表，并且从老的散列表中拿出一个数据放到新的散列表中。没插入一个数据就重复上面的过程，经过多次插入之后，老的散列表中的数据就被全部搬移到新散列表中了。")]),a._v(" "),_("p",[a._v("对于查询和删除操作，需要兼容新、老散列表。可以先在新的散列表中查找，如果没有找到，就去老的散列表找。")]),a._v(" "),_("h2",{attrs:{id:"如何选择散列冲突的解决方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何选择散列冲突的解决方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 如何选择散列冲突的解决方法")]),a._v(" "),_("p",[a._v("前面讲到了开放寻址法和链表法。这两种方法都常用，比如 Java 中 LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。")]),a._v(" "),_("h3",{attrs:{id:"开放寻址法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#开放寻址法","aria-hidden":"true"}},[a._v("#")]),a._v(" 开放寻址法")]),a._v(" "),_("p",[a._v("开发寻址法不像链表法，它的数据都存储在数组中，可以有效的利用 CPU 缓存加快查询速度。而且，这种散列表序列化比较简单，链表法包含指针，序列化比较麻烦。")]),a._v(" "),_("p",[a._v("但是，删除数据的时候比较麻烦，需要特殊标记已经删除的数据。另外所有数据都存数在数组中，冲突代价比较高，需要遍历来处理。所以使用开放寻址法解决散列冲突时，装载因子的上限不能太多，但是这也导致这种方法比链表法更加浪费资源。")]),a._v(" "),_("p",[_("strong",[a._v("总结一下，当数据量比较小、装载因子小的时候，适合采用开发寻址法。这也是 ThreadLocalMap 使用开发寻址法解决散列冲突的原因。")])]),a._v(" "),_("h2",{attrs:{id:"链表法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#链表法","aria-hidden":"true"}},[a._v("#")]),a._v(" 链表法")]),a._v(" "),_("p",[a._v("首先，链表法对内存的利用率比寻址法更高。因为链表结点可以在使用的时候再创建，不需要像开放寻址法一样事先申请好。")]),a._v(" "),_("p",[a._v("链表法对装载因子的容忍度比开放寻址法更高。开放寻址法的装载因子只能小于 1，而且接近 1 时，可能会导致大量的散列冲突，造成大量的探测。而链表法，只要散列函数的值比较均匀，即便装载因子变成 10，也就是链表长度变成了，查询效率有所下降，但是比开放寻址法还是快很多。")]),a._v(" "),_("p",[a._v("但是链表法需要存储指针，所以对于比较小的对象存储，还是比较消耗内存的，可能会让内存的消耗翻倍。而且，链表中的结点在内存中是零散的，不连续，所以对 CPU 缓存并不友好，这方面对执行效率有一定影响。")]),a._v(" "),_("p",[a._v("如果存储的是大对象，那么链表中指针的内存消耗对大对象来说，可以忽略不计的。")]),a._v(" "),_("p",[a._v("实际上，对链表法稍加改造，可以时间一个更高效的散列表。"),_("strong",[a._v("就是将链表改造为其他高效的动态数据结构，比如跳表、红黑树")]),a._v("。这样即便出现散列冲突，所有数据都在一个槽里，那么散列表查询的时间复杂度只不过退化为 O(logn)，而不是 O(n)。避免前面说的散列表碰撞攻击。")]),a._v(" "),_("p",[_("strong",[a._v("总结一下，基于链表解决散列冲突的方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如使用红黑树代替链表。")])])])},[],!1,null,null,null);t.default=r.exports}}]);