import{_ as t,r as e,o as r,c as n,a,b as l,d as s,e as d}from"./app.31755bf0.js";const i=JSON.parse('{"title":"排序","description":"","frontmatter":{},"headers":[{"level":2,"title":"如何分析一个算法","slug":"如何分析一个算法","link":"#如何分析一个算法","children":[{"level":3,"title":"排序算法的执行效率","slug":"排序算法的执行效率","link":"#排序算法的执行效率","children":[]},{"level":3,"title":"排序算法的内存消耗","slug":"排序算法的内存消耗","link":"#排序算法的内存消耗","children":[]},{"level":3,"title":"排序算法的稳定性","slug":"排序算法的稳定性","link":"#排序算法的稳定性","children":[]}]}],"relativePath":"algo/sort/sort.md"}'),h={name:"algo/sort/sort.md"},o=l("h1",{id:"排序",tabindex:"-1"},[s("排序 "),l("a",{class:"header-anchor",href:"#排序","aria-hidden":"true"},"#")],-1),g=d('<p>常用的排序算法有：</p><table><thead><tr><th style="text-align:center;">排序算法</th><th style="text-align:center;">时间复杂度</th><th style="text-align:center;">是否基于比较</th></tr></thead><tbody><tr><td style="text-align:center;">冒泡、插入、选择</td><td style="text-align:center;">O(n^2)</td><td style="text-align:center;">是</td></tr><tr><td style="text-align:center;">快排、归并</td><td style="text-align:center;">o(nlogn)</td><td style="text-align:center;">是</td></tr><tr><td style="text-align:center;">桶、计数、基数</td><td style="text-align:center;">O(n)</td><td style="text-align:center;">否</td></tr></tbody></table><h2 id="如何分析一个算法" tabindex="-1">如何分析一个算法 <a class="header-anchor" href="#如何分析一个算法" aria-hidden="true">#</a></h2><p>学习排序算法，除了要知道它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。分析一个排序算法应该要考虑以下几个方面</p><h3 id="排序算法的执行效率" tabindex="-1">排序算法的执行效率 <a class="header-anchor" href="#排序算法的执行效率" aria-hidden="true">#</a></h3><p>对于排序算法，需要从以下几点来衡量</p><ol><li><strong>最好情况、最坏情况、平均时间复杂度</strong>：为什么要区分这三种复杂度呢？第一，有些排序算法会区分，为了好对比，所以最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。。</li><li><strong>时间复杂度的系数、常数、低阶</strong>：时间复杂度反应的是执行时间随着数据规模增长的变化趋势，但是实际的开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，对于同一阶时间复杂度的排序算法的性能对比，就需要把系数、常数、低阶考虑进来。</li><li><strong>比较次数和交换（或移动）次数</strong>：对于基于比较的排序算法，会涉及两种操作，一种是元素比较大小，另一种是交换（或移动），所以分析执行效率的时候，应该把比较次数和交换（或移动次数）也考虑进来。</li></ol><h3 id="排序算法的内存消耗" tabindex="-1">排序算法的内存消耗 <a class="header-anchor" href="#排序算法的内存消耗" aria-hidden="true">#</a></h3><p>内存消耗可以通过空间复杂度来衡量。这里还引入一个概念，<strong>原地排序</strong>。原地排序算法，特指空间复杂度为 O(1) 的排序算法。冒泡、插入、选择都属于原地排序。</p><h3 id="排序算法的稳定性" tabindex="-1">排序算法的稳定性 <a class="header-anchor" href="#排序算法的稳定性" aria-hidden="true">#</a></h3><p>针对排序算法还有一个重要的度量指标，<strong>稳定性</strong>。就是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序顺序不变。</p><p>例如，一组数据 2，3，4，2，按照大小排序之后就是 2，2，3，4。</p><p>这里边有两个 2，经过某种排序算法排序之后，如果两个 2 的前后顺序没有变化，那么就把这种算法叫作<strong>稳定的排序算法</strong>；如果前后顺序发生变化，那对应的排序算法就叫作<strong>不稳定的排序算法</strong>。</p>',13);const c=t(h,[["render",function(t,l,s,d,i,h){const c=e("VueJobs");return r(),n("div",null,[o,a(c),g])}]]);export{i as __pageData,c as default};
