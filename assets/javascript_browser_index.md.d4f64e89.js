import{_ as e,r as l,o as i,c as r,a,b as s,d as t,e as p}from"./app.070707c9.js";const o=JSON.parse('{"title":"浏览器的多进程和JS单线程","description":"","frontmatter":{},"headers":[{"level":2,"title":"区分进程和线程","slug":"区分进程和线程","link":"#区分进程和线程","children":[]},{"level":2,"title":"浏览器是多线程的","slug":"浏览器是多线程的","link":"#浏览器是多线程的","children":[{"level":3,"title":"浏览器都包含哪些进程？","slug":"浏览器都包含哪些进程","link":"#浏览器都包含哪些进程","children":[]},{"level":3,"title":"浏览器多进程的优势","slug":"浏览器多进程的优势","link":"#浏览器多进程的优势","children":[]},{"level":3,"title":"重要的浏览器内核（渲染进程）","slug":"重要的浏览器内核-渲染进程","link":"#重要的浏览器内核-渲染进程","children":[]},{"level":3,"title":"浏览器进程和渲染进程的合作","slug":"浏览器进程和渲染进程的合作","link":"#浏览器进程和渲染进程的合作","children":[]}]},{"level":2,"title":"浏览器内核中线程之间的关系","slug":"浏览器内核中线程之间的关系","link":"#浏览器内核中线程之间的关系","children":[{"level":3,"title":"GUI 渲染线程与 JS 引擎线程互斥","slug":"gui-渲染线程与-js-引擎线程互斥","link":"#gui-渲染线程与-js-引擎线程互斥","children":[]},{"level":3,"title":"WebWorker，JS的多线程？","slug":"webworker-js的多线程","link":"#webworker-js的多线程","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"relativePath":"javascript/browser/index.md"}'),n={name:"javascript/browser/index.md"},h=s("h1",{id:"浏览器的多进程和js单线程",tabindex:"-1"},[t("浏览器的多进程和JS单线程 "),s("a",{class:"header-anchor",href:"#浏览器的多进程和js单线程","aria-hidden":"true"},"#")],-1),d=p('<p>查看了一些文章之后，整理了一下笔记，对浏览器多进程、JS单进程有个整体的理解。</p><h2 id="区分进程和线程" tabindex="-1">区分进程和线程 <a class="header-anchor" href="#区分进程和线程" aria-hidden="true">#</a></h2><p>线程和进程区分不清，看一个形象的比喻：</p><ol><li>进程是一个工厂，工厂有它的独立资源；</li><li>工厂之间相互独立；</li><li>线程是工厂中的工人，多个工人协作完成任务；</li><li>工厂内有一个或多个工人；</li><li>工人之间共享空间。</li></ol><p>再完善一下观念就是：</p><ol><li>工厂的资源 -&gt; 系统分配的内存（独立的一块内存）；</li><li>工厂之间的相互独立 -&gt; 进程之间相互独立；</li><li>多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务；</li><li>工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成；</li><li>工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）。</li></ol><p>如果是windows电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及cpu占有率：</p><p><img src="/fe-tutorial/assets/javascript-browser-eg1.7910c3d7.png" alt="eg1"></p><p>最后，再用较为官方的术语描述一遍：</p><ul><li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）。</li><li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</li></ul><p>另外还需要说明的是：</p><ul><li>不同进程之间也可以通信，不过代价较大</li><li>现在，一般通用的叫法单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）</li></ul><h2 id="浏览器是多线程的" tabindex="-1">浏览器是多线程的 <a class="header-anchor" href="#浏览器是多线程的" aria-hidden="true">#</a></h2><p>理解了进程与线程了区别后，需要明确：</p><ol><li>浏览器是多进程的</li><li>没打开一个 Tab 页，就相当于创建了一个独立的浏览器进程。</li></ol><p>一起看下，Chrome 打开一个页面需要启动多少进程？</p><p>和 Windows 任务管理器一样，Chrome 任务管理器也是用来展示运行中 Chrome 使用的进程信息的。从图中可以看到，Chrome 启动了 <strong>4 个进程</strong>：</p><p><img src="/fe-tutorial/assets/javascript-browser-eg2.ea3537c2.png" alt="eg2"></p><h3 id="浏览器都包含哪些进程" tabindex="-1">浏览器都包含哪些进程？ <a class="header-anchor" href="#浏览器都包含哪些进程" aria-hidden="true">#</a></h3><p>先看看最新的 Chrome 进程架构：</p><ul><li>浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li>渲染进程(浏览器内核)。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，也就是页面渲染，脚本执行，事件处理等。排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li>GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li><li>网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li>插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul><p>再看看上面的问题：仅仅打开了 1 个页面，为什么有 4 个进程？因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p><p>早期浏览器是单进程的，顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等，会存在一下问题：</p><ul><li>不稳定：插件或者渲染引擎的崩溃将导致整个浏览器的崩溃。</li><li>不流畅：所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。某个页面不合理的脚本（例如死循环）或者插件会让单进程浏览器变卡顿外，此外页面的内存泄漏也会造成页面的变慢。</li><li>不安全：恶意的脚本和插件可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</li></ul><p>默认情况下，Chrome 会为每个页面分配一个渲染进程（进程里面有多个子线程），也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p><p>那什么情况下多个页面会同时运行在一个渲染进程中呢？</p><p>要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将“同一站点”定义为<strong>根域名</strong>（例如，<a href="http://geekbang.org" target="_blank" rel="noreferrer">geekbang.org</a>）加上<strong>协议</strong>（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">https://time.geekbang.org</span></span>\n<span class="line"><span style="color:#A6ACCD;">https://www.geekbang.org</span></span>\n<span class="line"><span style="color:#A6ACCD;">https://www.geekbang.org:8080</span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</p><h3 id="浏览器多进程的优势" tabindex="-1">浏览器多进程的优势 <a class="header-anchor" href="#浏览器多进程的优势" aria-hidden="true">#</a></h3><p>多进程有效的提升了浏览器的稳定性、流畅性和安全性。</p><ul><li>避免单个崩溃影响整个浏览器</li><li>避免第三方插件崩溃影响整个浏览器</li><li>JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。</li><li>把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</li></ul><h3 id="重要的浏览器内核-渲染进程" tabindex="-1">重要的浏览器内核（渲染进程） <a class="header-anchor" href="#重要的浏览器内核-渲染进程" aria-hidden="true">#</a></h3><p>上面提到了这么多的进程，那么对于普通的前端操作来说，最终要的是什么呢？答案是渲染进程。</p><p>浏览器的渲染进程是多线程的，它都包含了哪些线程（列举一些主要常驻线程）：</p><ol><li>GUI 渲染线程</li></ol><ul><li>负责渲染浏览器界面，解析 HTML、CSS、构建 DOM 树和 RenderObject 树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程就会执行</li><li>注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时GUI线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</li></ul><ol start="2"><li>JS引擎线程</li></ol><ul><li>也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）</li><li>JS 引擎线程负责解析 Javascript 脚本，运行代码。</li><li>JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序</li><li>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><ol start="3"><li>事件触发线程</li></ol><ul><li>归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当 JS 引擎执行代码块如 setTimeout 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li></ul><ol start="4"><li>定时触发器线程</li></ol><ul><li>传说中的 <code>setInterval</code> 与 <code>setTimeout</code> 所在线程</li><li>浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）</li><li>注意，W3C 在 HTML 标准中规定，规定要求 <code>setTimeout</code> 中低于 4ms 的时间间隔算为 4ms。</li></ul><ol start="5"><li>异步http请求线程</li></ol><ul><li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li></ul><p>通过一张图总结一下：</p><p><img src="/fe-tutorial/assets/javascript-browser-eg3.e407ac71.png" alt="eg3"></p><p>为什么JS引擎是单线程的？</p><p>这个要回到 Js 历史了，布兰登·艾奇(Brendan Eich)老哥用 10 天创造 js。当时js用来干嘛，简单的浏览器交互，验证，操作一下dom是吧。那把它设计成那么复杂干什么，而且如果多线程的话，操作 dom 会出现麻烦的事情，假设一个线程读取 DOM 节点数据的同时，另一个线程把那个 DOM 节点删了，那就需要加锁了，呵呵。所以 js 一个线程就够了，也就是一步一步顺序运行下来。</p><h3 id="浏览器进程和渲染进程的合作" tabindex="-1">浏览器进程和渲染进程的合作 <a class="header-anchor" href="#浏览器进程和渲染进程的合作" aria-hidden="true">#</a></h3><p>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程：一个是主控进程，一个则是打开Tab页的渲染进程），然后在这前提下，看下整个大致的过程：</p><ol><li><p>浏览器进程收到用户请求，首先需要获取页面内容，随后将该任务通过 RendererHost 接口传递给渲染进程。</p></li><li><p>渲染进程收到消息，简单解析后，交给渲染线程，然后开始渲染。渲染线程接收请求，加载网页并渲染网页，这其中可能需要浏览器进程获取资源和需要 GPU 进程来帮助渲染；当然可能会有 JS 线程操作 DOM（这样可能会造成回流并重绘），最后渲染进程将结果传递给浏览器进程。</p></li><li><p>浏览器进程接收到结果并将结果绘制出来</p></li></ol><p>也就是下面这张图：</p><p><img src="/fe-tutorial/assets/javascript-browser-eg4.f9d6ddbf.png" alt="eg4"></p><h2 id="浏览器内核中线程之间的关系" tabindex="-1">浏览器内核中线程之间的关系 <a class="header-anchor" href="#浏览器内核中线程之间的关系" aria-hidden="true">#</a></h2><h3 id="gui-渲染线程与-js-引擎线程互斥" tabindex="-1">GUI 渲染线程与 JS 引擎线程互斥 <a class="header-anchor" href="#gui-渲染线程与-js-引擎线程互斥" aria-hidden="true">#</a></h3><p>由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p><p>因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JS 引擎为互斥的关系，当JS引擎执行时 GUI 线程会被挂起，GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行。</p><p>正因为这样，当 JS 执行时间过长的时候，比如大量计算，将会导致页面卡顿。</p><h3 id="webworker-js的多线程" tabindex="-1">WebWorker，JS的多线程？ <a class="header-anchor" href="#webworker-js的多线程" aria-hidden="true">#</a></h3><p>那么 JS 怎么处理大量计算的问题？</p><p>HTML5 中支持了Web Worker。通过使用 Web Workers，Web 应用程序可以在独立于主线程的后台线程中，运行一个脚本操作。这样做的好处是可以在独立线程中执行费时的处理任务，从而允许主线程（通常是UI线程）不会因此被阻塞/放慢。</p><p>这样理解下：</p><ol><li><p>创建 Worker 时，JS 引擎向浏览器申请开一个子线程，子线程是浏览器开的，完全受主线程控制，而且不能操作 DOM。</p></li><li><p>JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）。</p></li></ol><p>所以，如果有非常耗时的工作，请单独开一个 Worker 线程，这样里面不管如何翻天覆地都不会影响 JS 引擎主线程，只待计算出结果后，将结果通信给主线程即可，perfect!</p><p>而且注意下，JS 引擎是单线程的，这一点的本质仍然未改变，Worker 可以理解是浏览器给 JS 引擎开的外挂，专门用来解决那些大量计算问题。</p><p>除了 Web Worker 之外， worker 之外，还有一些其他种类的 worker ：</p><ul><li>Shared Workers：可被不同的窗体的多个脚本运行，例如 IFrames 等，只要这些 workers 处于同一主域。共享 worker 比专用 worker 稍微复杂一点 — 脚本必须通过活动端口进行通讯。详情请见 SharedWorker。</li><li>Service Workers：一般作为 web 应用程序、浏览器和网络（如果可用）之间的代理服务。他们旨在（除开其他方面）创建有效的离线体验，拦截网络请求，以及根据网络是否可用采取合适的行动，更新驻留在服务器上的资源。他们还将允许访问推送通知和后台同步 API。</li><li>Chrome Workers：是一种仅适用于 firefox 的 worker。如果您正在开发附加组件，希望在扩展程序中使用 worker 且可以访问 js-ctypes，那么可以使用Chrome Workers。详情请见 ChromeWorker。</li><li>音频 Workers：可以在网络 worker 上下文中直接完成脚本化音频处理.</li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-hidden="true">#</a></h2><ul><li><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7#heading-8" target="_blank" rel="noreferrer">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noreferrer">进程与线程的一个简单解释</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" target="_blank" rel="noreferrer">MDN - Web Workers API</a></li></ul>',70);const c=e(n,[["render",function(e,s,t,p,o,n){const c=l("VueJobs");return i(),r("div",null,[h,a(c),d])}]]);export{o as __pageData,c as default};
