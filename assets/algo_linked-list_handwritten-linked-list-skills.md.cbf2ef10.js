import{_ as e,r as a,o as s,c as n,a as l,b as t,d as p,e as i}from"./app.a6773dcb.js";const r=JSON.parse('{"title":"手写链表的技巧","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. 理解指针或引用的含义","slug":"_1-理解指针或引用的含义","link":"#_1-理解指针或引用的含义","children":[]},{"level":2,"title":"2. 警惕指针丢失和内存泄漏","slug":"_2-警惕指针丢失和内存泄漏","link":"#_2-警惕指针丢失和内存泄漏","children":[]},{"level":2,"title":"3. 重点留意边界条件处理","slug":"_3-重点留意边界条件处理","link":"#_3-重点留意边界条件处理","children":[]},{"level":2,"title":"4. 举例画图，辅助思考","slug":"_4-举例画图-辅助思考","link":"#_4-举例画图-辅助思考","children":[]},{"level":2,"title":"5. 多些多练，没有捷径","slug":"_5-多些多练-没有捷径","link":"#_5-多些多练-没有捷径","children":[]}],"relativePath":"algo/linked-list/handwritten-linked-list-skills.md"}'),d={name:"algo/linked-list/handwritten-linked-list-skills.md"},o=t("h1",{id:"手写链表的技巧",tabindex:"-1"},[p("手写链表的技巧 "),t("a",{class:"header-anchor",href:"#手写链表的技巧","aria-hidden":"true"},"#")],-1),c=i('<p>写好链表并不容易，需要一些方法和技巧。</p><h2 id="_1-理解指针或引用的含义" tabindex="-1">1. 理解指针或引用的含义 <a class="header-anchor" href="#_1-理解指针或引用的含义" aria-hidden="true">#</a></h2><p>看懂链表的结构并不是很难，但是一旦把它和指针混在一起，就容易让人摸不着头脑。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。</p><p>对于指针的理解，需要记住：</p><p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p><p>回到链表的代码中，来解释一下。</p><p>编写链表的代码，经常有 <code>p-&gt;next=q</code>，这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。</p><p>还有一个更复杂的，也写链表代码经常会用到的：<code>p-&gt;next=p-&gt;next-&gt;next</code>。这行代码表示，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址。</p><h2 id="_2-警惕指针丢失和内存泄漏" tabindex="-1">2. 警惕指针丢失和内存泄漏 <a class="header-anchor" href="#_2-警惕指针丢失和内存泄漏" aria-hidden="true">#</a></h2><p>写链表代码的时候，一定注意不要弄丢了指针。看个例子：</p><p><img src="/fe-tutorial/assets/dataStructure-linked-tips-eg1.af0b6b4a.png" alt="tips eg1"></p><p>如图，想在相邻的 a 和 b 节点之间插入 x，假设当前指针 p 指向结点 a。那么一不小心，就会写成下面的样子。如果把代码实现成下面这样，就会发生指针丢失和内存泄露。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">p-&gt;next = x;</span></span>\n<span class="line"><span style="color:#A6ACCD;">x-&gt;next = p-&gt;next</span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>第一步之后，p-&gt;next 已经不再指向 b 节点，而是指向 x。第 2 行代码相当于将 x 赋值给 x-&gt;next，自己指向自己。此时，整个链表就断成两半了，从节点 b 往后的节点都无法访问到了。</p><p><strong>所以，我们插入结点时，一定要注意操作的顺序</strong>，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。对于刚才的代码，需要把顺序颠倒一下就可以了：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">x-&gt;next = p-&gt;next</span></span>\n<span class="line"><span style="color:#A6ACCD;">p-&gt;next = x;</span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="_3-重点留意边界条件处理" tabindex="-1">3. 重点留意边界条件处理 <a class="header-anchor" href="#_3-重点留意边界条件处理" aria-hidden="true">#</a></h2><p>一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。</p><p>经常用来检查链表代码是否正确的边界条件有这样几个：</p><ul><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个结点时，代码是否能正常工作？</li><li>如果链表只包含两个结点时，代码是否能正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ul><p>写完链表代码后，出来看写的代码在正常情况下能否工作，还要看在上面列举的几个边界条件下，代码能够仍然正常工作。如果在这些边界条件下都没问题，那基本上就没有问题了。</p><p>当然，边界条件不止这些，还有针对自己的场景的特定边界。</p><p><strong>实际上，不光是写链表代码，写任何代码，千万不要只是实现业务正常情况下的功能。一定要多想想，你写的代码在运行的时候，可能后遇到哪些边界或者异常情况，遇到了应该怎么处理，这样写出来的代码才够健壮。</strong></p><h2 id="_4-举例画图-辅助思考" tabindex="-1">4. 举例画图，辅助思考 <a class="header-anchor" href="#_4-举例画图-辅助思考" aria-hidden="true">#</a></h2><p>对于稍微复杂的链表操作，比如单链表反转，指针一会指着，一会指那，自己一会就被绕晕了。这个时候就需要<strong>举例法</strong>和<strong>画图法</strong>了。</p><p>你可以找一个具体的例子，把它画在纸上，这样就会感觉到思路清晰很多。比如往单链表中插入一个数据这样一个操作，可以把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示：</p><p><img src="/fe-tutorial/assets/dataStructure-linked-tips-eg2.56801e41.png" alt="tips eg2"></p><p>看图写代码，那就简单很多了！</p><p>而且，写完代码之后，也可以举几个例子，画在纸上，照着代码走一遍，很容易发现 bug。</p><h2 id="_5-多些多练-没有捷径" tabindex="-1">5. 多些多练，没有捷径 <a class="header-anchor" href="#_5-多些多练-没有捷径" aria-hidden="true">#</a></h2><p>多写多练，出问题就一点一点调试，熟能生巧。</p><p>不要害怕写链表，以下是 5 个常见的链表操作，把它们都写熟练：</p><ul><li>单链表反转；</li><li>链表中环的检测；</li><li>两个有序的链表合并；</li><li>删除链表倒数第 n 个结点；</li><li>求链表的中间结点。</li></ul>',33);const h=e(d,[["render",function(e,t,p,i,r,d){const h=a("VueJobs");return s(),n("div",null,[o,l(h),c])}]]);export{r as __pageData,h as default};
