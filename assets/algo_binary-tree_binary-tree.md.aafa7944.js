import{N as s}from"./chunks/nx-tip.3b3b719a.js";import{r as n,o as a,c as l,a as p,b as o,d as e,e as r}from"./app.31755bf0.js";const t=o("h1",{id:"二叉树",tabindex:"-1"},[e("二叉树 "),o("a",{class:"header-anchor",href:"#二叉树","aria-hidden":"true"},"#")],-1),c=r('<p>二叉树是一种非线性表结构，二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？</p><h2 id="树-tree" tabindex="-1">树（Tree） <a class="header-anchor" href="#树-tree" aria-hidden="true">#</a></h2><p>这里的树和生活中的“树”很像，先看看几棵树：</p><p><img src="/fe-tutorial/assets/dataStructure-tree.d9879f8f.png" alt="tree"></p><p>树的常用概念有：</p><ol><li>节点：树中的每个元素称为节点；</li><li>父子关系：相连的相邻节点之间的关系叫作父子关系；</li><li>父节点：如下，A 节点就是 B 节点的父节点；</li><li>子节点：如下，B 节点就是 A 节点的子节点；</li><li>根节点：没有父节点的节点，也就是图中的 A；</li><li>叶子节点（或者叶节点）：没有子节点的节点，也就是图中的 G、H、I、J、K；</li><li>节点的高度：<strong>节点到叶子节点</strong>的最长路径（边数）；</li><li>节点的深度：<strong>根节点到这个节点</strong>经历的边的个数；</li><li>节点的层数：节点的深度 <strong>+ 1</strong>；</li><li>树的高度：根节点的高度。</li></ol><p><img src="/fe-tutorial/assets/dataStructure-tree-example.1b4f37e4.png" alt="tree-example"></p><p><strong>高度就类似楼层一样，从下往上，起点记为 0；而深度类似水的深度，从上往下，起点也记为 0；层数跟深度类似，不过起点记为 1。</strong></p><h2 id="二叉树-1" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树-1" aria-hidden="true">#</a></h2><p>树的结构中常用的还是二叉树。</p><ol><li>二叉树</li></ol><p>二叉树的每个节点<strong>最多</strong>有两个子节点，分别是左子节点和右子节点。注意这里是最多也就是并不要求都有两个子节点。</p><ol start="2"><li>满二叉树</li></ol><p>二叉树中，叶子节点都在底层，并且除了叶子节点之外，每个节点<strong>都有</strong>左右两个子节点，这种二叉树就叫作满二叉树。</p><ol start="3"><li>完全二叉树</li></ol><p>二叉树中，叶子节点都在<strong>最底下两层</strong>，最后一层的叶子节点都<strong>靠左排列</strong>，并且除了最后一层，其他层的节点个数都要<strong>达到最大</strong>，这种二叉树叫作完全二叉树。</p><p><img src="/fe-tutorial/assets/dataStructure-tree-binaryTree.db58ac7f.png" alt="binaryTree"></p>',17),i=r('<p>要理解完全二叉树的定义的由来，从二叉树的存储说起。</p><h2 id="二叉树的存储" tabindex="-1">二叉树的存储 <a class="header-anchor" href="#二叉树的存储" aria-hidden="true">#</a></h2><p>存储二叉树有两种方法：<strong>链式存储法</strong>和<strong>顺序存储法</strong>。</p><p><strong>1. 链式存储法</strong></p><p>每个节点有 3 个字段，其中一个存储数据，另外是两个指向左右子节点的指针。只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储结构比较常用，大部分二叉树都是通过这种结构来实现。</p><p><img src="/fe-tutorial/assets/dataStructure-tree-binaryTree-linkedStore.65fbf0cd.png" alt="linkedStore"></p><p><strong>2. 顺序存储法</strong></p><p>用数组来存储，如果节点 X 存储在下标为 <code>i</code> 的位置，那它的左子节点存储在 <code>2 * i</code> 的位置，右子节点存储在 <code>2 * i + 1</code> 的位置。反过来，下标 <code>i/2</code> 位置存储的就是它的父节点。通过这种方式，只要知道根节点的存储位置（一般情况，为了方便计算，<strong>根节点会存储在下标为 1 的位置</strong>），就可以通过下标的计算，把整棵树都串起来。</p><p><img src="/fe-tutorial/assets/dataStructure-tree-binaryTree-arrayStore.d03b6130.png" alt="arrayStore"></p><p>这个时候，如果是完全二叉树，它仅仅浪费一个下标为 0 的存储位置，而非完全二叉树，其实就会浪费比较多的数组存储空间。</p><p><strong>所以，如果一棵二叉树是完全二叉树，那么使用数组存储是最节省内存的一种方式。</strong></p><h2 id="二叉树的遍历" tabindex="-1">二叉树的遍历 <a class="header-anchor" href="#二叉树的遍历" aria-hidden="true">#</a></h2><p>如何将所有节点都遍历打印出来？经典的方法有 3 种：<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。</p><ol><li>前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</li><li>中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</li><li>后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</li></ol><p>二叉树的前、中、后序遍历就是一个递归的过程。为了写递归代码，需要先写出递推公式。而写递推公式，关键就是把要解决的问题 a，分解成子问题 b 和 c，再看如何利用 b，c 来解决 A。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">// 前序遍历的递推公式</span></span>\n<span class="line"><span style="color:#A6ACCD;">preOrder(r) = print r -&gt; preOrder(r-&gt;left) -&gt; preOrder(r-&gt;right)</span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span>\n<span class="line"><span style="color:#A6ACCD;">// 中序遍历的递推公式</span></span>\n<span class="line"><span style="color:#A6ACCD;">preOrder(r) = preOrder(r-&gt;left) -&gt; print r -&gt; preOrder(r-&gt;right)</span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span>\n<span class="line"><span style="color:#A6ACCD;">// 后序遍历的递推公式</span></span>\n<span class="line"><span style="color:#A6ACCD;">preOrder(r) = preOrder(r-&gt;left) -&gt; preOrder(r-&gt;right) -&gt; print r </span></span>\n<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>根据递推公式，用代码实现为：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">preOrder</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">node</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">return</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">preOrder</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">left</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">preOrder</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">right</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">inOrder</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">node</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">return</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">inOrder</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">left</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">inOrder</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">right</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">postOrder</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">node</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">return</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">postOrder</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">left</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">postOrder</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">right</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><h3 id="时间复杂度分析" tabindex="-1">时间复杂度分析 <a class="header-anchor" href="#时间复杂度分析" aria-hidden="true">#</a></h3><p>从前、中、后序遍历的顺序图中，每个节点最多被访问两次，所以遍历操作的时间复杂度跟节点的个数 n 成正比，也就是说时间复杂度为 O(n)。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><p>最常用的树就是二叉树，二叉树的每个节点最多只有两个子节点，分别是左子节点和右子节点。二叉树中，有两种树比较特殊，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p><p>回答开头的问题，二叉树有两种存储方法：用链表存储和用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组会比较浪费存储空间。</p><p>前、中、后序遍历都属于按深度遍历，另外还有一种按层遍历的方式。</p>',24),F=JSON.parse('{"title":"二叉树","description":"","frontmatter":{},"headers":[{"level":2,"title":"树（Tree）","slug":"树-tree","link":"#树-tree","children":[]},{"level":2,"title":"二叉树","slug":"二叉树-1","link":"#二叉树-1","children":[]},{"level":2,"title":"二叉树的存储","slug":"二叉树的存储","link":"#二叉树的存储","children":[]},{"level":2,"title":"二叉树的遍历","slug":"二叉树的遍历","link":"#二叉树的遍历","children":[{"level":3,"title":"时间复杂度分析","slug":"时间复杂度分析","link":"#时间复杂度分析","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"relativePath":"algo/binary-tree/binary-tree.md"}'),y=Object.assign({name:"algo/binary-tree/binary-tree.md"},{setup:o=>(o,e)=>{const r=n("VueJobs");return a(),l("div",null,[t,p(r),c,p(s,{text:"完全二叉树的特征并不是很明显，为什么要特意说明呢？为什么要求它最后一层的叶子节点靠左排列？它的定义目的在哪？"}),i])}});export{F as __pageData,y as default};
