import{_ as s,r as a,o,c as e,a as n,b as l,d as p,e as c}from"./app.070707c9.js";const t=JSON.parse('{"title":"栈空间和堆空间","description":"","frontmatter":{},"headers":[{"level":2,"title":"基本类型和引用类型","slug":"基本类型和引用类型","link":"#基本类型和引用类型","children":[]},{"level":2,"title":"内存空间","slug":"内存空间","link":"#内存空间","children":[]},{"level":2,"title":"栈空间和堆空间","slug":"栈空间和堆空间-1","link":"#栈空间和堆空间-1","children":[{"level":3,"title":"基本类型保存在栈中，引用类型保存在堆中","slug":"基本类型保存在栈中-引用类型保存在堆中","link":"#基本类型保存在栈中-引用类型保存在堆中","children":[]},{"level":3,"title":"为什么一定要分“堆”和“栈”两个存储空间呢？","slug":"为什么一定要分-堆-和-栈-两个存储空间呢","link":"#为什么一定要分-堆-和-栈-两个存储空间呢","children":[]}]},{"level":2,"title":"再谈闭包的存储","slug":"再谈闭包的存储","link":"#再谈闭包的存储","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"relativePath":"javascript/browser/heap-stack.md"}'),r={name:"javascript/browser/heap-stack.md"},d=l("h1",{id:"栈空间和堆空间",tabindex:"-1"},[p("栈空间和堆空间 "),l("a",{class:"header-anchor",href:"#栈空间和堆空间","aria-hidden":"true"},"#")],-1),i=c('<p>接下来 JavaScript 的内存机制，包括数据在内存中的存放、JavaScript 处理垃圾回收。</p><h2 id="基本类型和引用类型" tabindex="-1">基本类型和引用类型 <a class="header-anchor" href="#基本类型和引用类型" aria-hidden="true">#</a></h2><p>ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。</p><p>基本类型有 6 种：</p><ul><li><code>Number</code></li><li><code>String</code></li><li><code>Null</code></li><li><code>Undefined</code></li><li><code>Boolean</code></li><li><code>Symbol</code></li></ul><p>引用数据类型则有 Object、Array 等。</p><p>之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。到底怎么个不一样法呢？接下来看一下它们是怎么存储的。</p><h2 id="内存空间" tabindex="-1">内存空间 <a class="header-anchor" href="#内存空间" aria-hidden="true">#</a></h2><p>JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类：</p><p><img src="/fe-tutorial/assets/javascript-browser-store-eg1.855faf90.png" alt="eg1"></p><p>可以看出来，在 JavaScript 的执行过程中，<strong>主要有三种类型内存空间，分别是代码空间、栈空间和堆空间</strong>。其中的代码空间主要是存储可执行代码的。</p><h2 id="栈空间和堆空间-1" tabindex="-1">栈空间和堆空间 <a class="header-anchor" href="#栈空间和堆空间-1" aria-hidden="true">#</a></h2><h3 id="基本类型保存在栈中-引用类型保存在堆中" tabindex="-1">基本类型保存在栈中，引用类型保存在堆中 <a class="header-anchor" href="#基本类型保存在栈中-引用类型保存在堆中" aria-hidden="true">#</a></h3><p>栈空间就是调用栈，是用来存储执行环境的。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">b</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">c</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> name</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">d</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">d</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>调用 <code>foo()</code> 是会创建一个函数执行环境，当执行到第 3 行代码时，其调用栈的状态，你可以参考下面这张调用栈状态图：</p><p><img src="/fe-tutorial/assets/javascript-browser-store-eg2.0d77aea5.png" alt="eg2"></p><p>变量 <code>a</code> 和变量 <code>b</code> 的值都被保存在执行环境中，而执行环境又被压入到栈中，所以你也可以认为变量 <code>a</code> 和变量 <code>b</code> 的值都是存放在栈中的。</p><p>接下来，到第 4 行代码的时候就不一样了。JavaScript 引擎判断右边的值是一个引用类型。这时和前面的处理方式就不一样了。</p><p><strong>JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 <code>c</code> 的变量值</strong>，最终分配好内存的示意图如下所示：</p><p><img src="/fe-tutorial/assets/javascript-browser-store-eg3.07029963.png" alt="eg3"></p><p>可以看到，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的。</p><p><strong>所以，基本类型保存在栈中，而引用类型保存在堆中。基本类型的赋值是复制变量值，而引用类型赋值是复制引用地址。</strong></p><h3 id="为什么一定要分-堆-和-栈-两个存储空间呢" tabindex="-1">为什么一定要分“堆”和“栈”两个存储空间呢？ <a class="header-anchor" href="#为什么一定要分-堆-和-栈-两个存储空间呢" aria-hidden="true">#</a></h3><p>为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？</p><p><strong>这是不可以的，这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。</strong></p><p>比如文中的 <code>foo</code> 函数执行结束了，JavaScript 引擎需要离开当前的执行环境，只需要将指针下移到上个执行环境的地址就可以了，<code>foo</code> 函数执行环境栈区空间全部回收。</p><p><img src="/fe-tutorial/assets/javascript-browser-store-eg4.3f2bf3bd.png" alt="eg4"></p><p>所以通常情况下，栈空间都不会设置太大，主要用来存放一些基本类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。</p><p>最后执行 <code>d = c</code> 就是把 <code>c</code> 的引用地址赋值给 <code>d</code>，这样变量 c 和 变量 d 都指向同一个堆中的对象。</p><p><img src="/fe-tutorial/assets/javascript-browser-store-eg5.cc301063.png" alt="eg5"></p><p>所以进行赋值的时候需要考虑是否需要<a href="../programming-language/deep-clone-shallow-clone" target="_blank" rel="noreferrer">深拷贝和浅拷贝</a></p><h2 id="再谈闭包的存储" tabindex="-1">再谈闭包的存储 <a class="header-anchor" href="#再谈闭包的存储" aria-hidden="true">#</a></h2><p>先看段代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"></span>\n<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">myName</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">bar</span><span style="color:#89DDFF;">&quot;</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">test1</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">test2</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">innerBar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">setName</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">newName</span><span style="color:#89DDFF;">){</span></span>\n<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">myName</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newName</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">},</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">getName</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){</span></span>\n<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">test1</span><span style="color:#F07178;">)</span></span>\n<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">myName</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">innerBar</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> bar </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span></span>\n<span class="line"><span style="color:#A6ACCD;">bar</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setName</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">baz</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"><span style="color:#A6ACCD;">bar</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getName</span><span style="color:#A6ACCD;">() </span><span style="color:#676E95;">// &quot;baz&quot;</span></span>\n<span class="line"></span></code></pre></div><p>通过前面的分析，我们知道 <code>myName</code>、<code>test1</code>、<code>test2</code> 都是基本类型，在 <code>foo</code> 执行的时候，它们将会压入栈中；当 <code>foo</code> 执行结束之后，<code>foo</code> 函数的执行环境将会被销毁，其内部的变量 <code>myName</code>、<code>test1</code>、<code>test2</code> 也<strong>应该一同被销毁</strong>。</p><p>但是，<code>foo()</code> 产生了闭包，所以当 <code>foo</code> 函数的执行环境将会被销毁是，变量 <code>myName</code>、<code>test1</code> 并没有一起被销毁，而是保存在内存中。应该怎么解释呢？</p><p>分析一下这段代码的执行过程：</p><ol><li>当 JavaScript 引擎执行到 <code>foo</code> 函数时，首先会编译，并创建一个空执行环境。</li><li>在编译过程中，遇到内部函数 <code>setName</code>，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 <code>foo</code> 函数中的 <code>myName</code> 变量，<strong>由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“<code>closure(foo)</code>”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 <code>myName</code> 变量</strong>。</li><li>接着继续扫描到 <code>getName</code> 方法时，发现该函数内部还引用变量 <code>test1</code>，于是 JavaScript 引擎又将 <code>test1</code> 添加到“<code>closure(foo)</code>”对象中。这时候堆中的“<code>closure(foo)</code>”对象中就包含了 <code>myName</code> 和 <code>test1</code> 两个变量了。</li><li>由于 <code>test2</code> 并没有被内部函数引用，所以 <code>test2</code> 依然保存在调用栈中。</li></ol><p><img src="/fe-tutorial/assets/javascript-browser-store-eg6.412ae3b3.png" alt="eg5"></p><p>从上图可以看出，当执行到 <code>foo</code> 函数时，就产生了闭包；当 <code>foo</code> 函数执行结束之后，返回的 <code>getName</code> 和 <code>setName</code> 方法都引用“<code>clourse(foo)</code>”对象。即使 <code>foo</code> 函数退出了，“<code>clourse(foo)</code>”依然被其内部的 <code>getName</code> 和 <code>setName</code> 方法引用。所以在下次调用 <code>bar.setName</code> 或者 <code>bar.getName</code> 时，创建的执行环境中就包含了“<code>clourse(foo)</code>”。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-hidden="true">#</a></h2><ul><li><a href="https://time.geekbang.org/column/article/129596" target="_blank" rel="noreferrer">栈空间和堆空间：数据是如何存储的？</a></li></ul>',43);const y=s(r,[["render",function(s,l,p,c,t,r){const y=a("VueJobs");return o(),e("div",null,[d,n(y),i])}]]);export{t as __pageData,y as default};
