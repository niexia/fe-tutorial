import{_ as s,r as a,o as n,c as l,a as p,b as o,d as e,e as r}from"./app.a6773dcb.js";const c=JSON.parse('{"title":"垃圾回收","description":"","frontmatter":{},"headers":[{"level":2,"title":"垃圾回收的必要性","slug":"垃圾回收的必要性","link":"#垃圾回收的必要性","children":[]},{"level":2,"title":"垃圾回收机制","slug":"垃圾回收机制","link":"#垃圾回收机制","children":[{"level":3,"title":"标记清除","slug":"标记清除","link":"#标记清除","children":[]},{"level":3,"title":"引用计数","slug":"引用计数","link":"#引用计数","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"relativePath":"javaScript/browser/garbage-collection.md"}'),t={name:"javaScript/browser/garbage-collection.md"},y=o("h1",{id:"垃圾回收",tabindex:"-1"},[e("垃圾回收 "),o("a",{class:"header-anchor",href:"#垃圾回收","aria-hidden":"true"},"#")],-1),F=r('<p>前面已经知道基本类型存储在栈空间中，引用类型存储在堆空间中。通过这种方式，解决了数据的存储问题。</p><p>不过数据使用之后，如果不需要了（垃圾数据），但是还保留在内存中，那就会导致占用内存越来越大，所以需要对这些垃圾数据进行回收，释放内存空间。</p><h2 id="垃圾回收的必要性" tabindex="-1">垃圾回收的必要性 <a class="header-anchor" href="#垃圾回收的必要性" aria-hidden="true">#</a></h2><p>下面这段话引自《JavaScript权威指南（第四版）》</p><blockquote><p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</p></blockquote><p>这段话解释了为什么需要系统需要垃圾回收，JS 不像 C/C++，它有自己的一套垃圾回收机制（Garbage Collection）。JavaScrip t的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。</p><p>例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">before</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">override a</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 重写a</span></span>\n<span class="line"></span></code></pre></div><p>这段代码运行之后，“before”这个字符串失去了引用（之前是被 a 引用），系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用。</p><h2 id="垃圾回收机制" tabindex="-1">垃圾回收机制 <a class="header-anchor" href="#垃圾回收机制" aria-hidden="true">#</a></h2><p>垃圾回收有两种方法：标记清除和引用计数。其中标记清除更为常用。</p><h3 id="标记清除" tabindex="-1">标记清除 <a class="header-anchor" href="#标记清除" aria-hidden="true">#</a></h3><p>这是 JavaScript 中<strong>最常见</strong>的垃圾回收方式。</p><p>当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。</p><p>可以使用任何方式来标记变量。如何标记其实并不重要，重要的是采取什么策略。</p><p>垃圾收集器在运行的时候会给存储在内存中的<strong>所有变量都加上标记</strong>（当然，可以使用任何标记方式）。然后，它会<strong>去掉</strong>环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p><p>简单说：就是垃圾回收器会每隔一段时间扫描一次内存，当然这个时间应该是很短，在扫描的过程中垃圾回收器会把所有的内存的变量全部加上标记，然后如果有你需要用到的内存，垃圾回收器就会把你需要用到的内存的标记删掉，意思就是说，这个内存我不清除，但是会把有标记的全部删掉，这就是垃圾回收器的一次清理工作。</p><p>举个例子：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> m </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">n </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">19</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 把 m, n, add() 标记为进入环境。</span></span>\n<span class="line"><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(m</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> n) </span><span style="color:#676E95;">// 把 a, b, c 标记为进入环境。</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(n) </span><span style="color:#676E95;">// a, b, c 标记为离开环境，等待垃圾回收。</span></span>\n<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">c</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">b</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">c</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span>\n<span class="line"></span></code></pre></div><h3 id="引用计数" tabindex="-1">引用计数 <a class="header-anchor" href="#引用计数" aria-hidden="true">#</a></h3><p>另一种不太常见的垃圾回收策略是引用计数。</p><p>引用计数的含义是跟踪记录每个值被引用的次数。<strong>当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1。当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来</strong>。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</p><p>但是用这种方法存在着一个问题，下面来看看代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">problem</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">objA</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">objB</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">objA</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">someOtherObject</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">objB</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">objB</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">anotherObject</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">objA</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><p>在这个例子中，<code>objA</code> 和 <code>objB</code> 通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，<code>objA</code> 和 <code>objB</code> 还将会继续存在，因为他们的引用次数永远不会是 0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-hidden="true">#</a></h2><ul><li><a href="https://juejin.im/post/5cb33660e51d456e811d2687" target="_blank" rel="noreferrer">JavaScript中的垃圾回收和内存泄漏</a></li><li><a href="https://www.cnblogs.com/hustskyking/archive/2013/04/27/garbage-collection.html" target="_blank" rel="noreferrer">JavaScript垃圾回收机制</a></li><li><a href="https://zhuanlan.zhihu.com/p/23992332" target="_blank" rel="noreferrer">JavaScript 中的垃圾回收</a></li></ul>',27);const D=s(t,[["render",function(s,o,e,r,c,t){const D=a("VueJobs");return n(),l("div",null,[y,p(D),F])}]]);export{c as __pageData,D as default};
